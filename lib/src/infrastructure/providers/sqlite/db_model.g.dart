// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'db_model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:CategoryDBModel.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// CategoryDBModel TABLE
class TableCategoryDBModel extends SqfEntityTableBase {
  TableCategoryDBModel() {
    // declare properties of EntityTable
    tableName = 'Category';
    primaryKeyName = 'category_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: true, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('description', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('color', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('icon', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCategoryDBModel();
  }
}

// GeodataDBModel TABLE
class TableGeodataDBModel extends SqfEntityTableBase {
  TableGeodataDBModel() {
    // declare properties of EntityTable
    tableName = 'Geodata';
    primaryKeyName = 'geodata_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('longitude', DbType.real,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('latitude', DbType.real,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableCategoryDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'category_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableGeodataDBModel();
  }
}

// ColumnDBModel TABLE
class TableColumnDBModel extends SqfEntityTableBase {
  TableColumnDBModel() {
    // declare properties of EntityTable
    tableName = 'Column';
    primaryKeyName = 'column_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableCategoryDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'category_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableFieldTypeDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'field_type_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableColumnDBModel();
  }
}

// FieldTypeDBModel TABLE
class TableFieldTypeDBModel extends SqfEntityTableBase {
  TableFieldTypeDBModel() {
    // declare properties of EntityTable
    tableName = 'FieldType';
    primaryKeyName = 'field_type_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: true, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('meta_type', DbType.text,
          isUnique: true, isNotNull: true, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFieldTypeDBModel();
  }
}

// StaticSelectionDBModel TABLE
class TableStaticSelectionDBModel extends SqfEntityTableBase {
  TableStaticSelectionDBModel() {
    // declare properties of EntityTable
    tableName = 'StaticSelection';
    primaryKeyName = 'static_selection_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('options', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableFieldTypeDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'field_type_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableStaticSelectionDBModel();
  }
}

// FieldValueDBModel TABLE
class TableFieldValueDBModel extends SqfEntityTableBase {
  TableFieldValueDBModel() {
    // declare properties of EntityTable
    tableName = 'FieldValue';
    primaryKeyName = 'field_value_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('value', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableGeodataDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'geodata_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableFieldTypeDBModel.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'column_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFieldValueDBModel();
  }
}

// VMarker TABLE
class TableVMarker extends SqfEntityTableBase {
  TableVMarker() {
    // declare properties of EntityTable
    tableName = 'VMarkers';
    objectType = ObjectType.view;
    sqlStatement = geobaseDBModel.databaseTables![6].sqlStatement;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('kind', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('icon', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('color', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableGeodataDBModel.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'geodata_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVMarker();
  }
}

// VStaticSelection TABLE
class TableVStaticSelection extends SqfEntityTableBase {
  TableVStaticSelection() {
    // declare properties of EntityTable
    tableName = 'VStaticSelections';
    objectType = ObjectType.view;
    sqlStatement = geobaseDBModel.databaseTables![7].sqlStatement;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text,
          isUnique: true, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('meta_type', DbType.text,
          isUnique: true, isNotNull: true, isIndex: false),
      SqfEntityFieldBase('options', DbType.text,
          isUnique: false, isNotNull: true, isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableFieldTypeDBModel.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'field_type_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
      SqfEntityFieldRelationshipBase(
          TableStaticSelectionDBModel.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'static_selection_id',
          isUnique: false,
          isNotNull: true,
          isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVStaticSelection();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class GeobaseModel extends SqfEntityModelProvider {
  GeobaseModel() {
    databaseName = geobaseDBModel.databaseName;
    password = geobaseDBModel.password;
    dbVersion = geobaseDBModel.dbVersion;
    databaseTables = [
      TableCategoryDBModel.getInstance,
      TableGeodataDBModel.getInstance,
      TableColumnDBModel.getInstance,
      TableFieldTypeDBModel.getInstance,
      TableStaticSelectionDBModel.getInstance,
      TableFieldValueDBModel.getInstance,
      TableVMarker.getInstance,
      TableVStaticSelection.getInstance,
    ];

    bundledDatabasePath = geobaseDBModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region CategoryDBModel
class CategoryDBModel {
  CategoryDBModel(
      {this.category_id, this.name, this.description, this.color, this.icon}) {
    _setDefaultValues();
  }
  CategoryDBModel.withFields(
      this.name, this.description, this.color, this.icon) {
    _setDefaultValues();
  }
  CategoryDBModel.withId(
      this.category_id, this.name, this.description, this.color, this.icon) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CategoryDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    category_id = int.tryParse(o['category_id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    if (o['icon'] != null) {
      icon = int.tryParse(o['icon'].toString());
    }
  }
  // FIELDS (CategoryDBModel)
  int? category_id;
  String? name;
  String? description;
  int? color;
  int? icon;

  BoolResult? saveResult;
  // end FIELDS (CategoryDBModel)

// COLLECTIONS & VIRTUALS (CategoryDBModel)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plGeodataDBModels', 'plField2'..]) or so on..
  List<GeodataDBModel>? plGeodataDBModels;

  /// get GeodataDBModel(s) filtered by category_id=category_id
  GeodataDBModelFilterBuilder? getGeodataDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (category_id == null) {
      return null;
    }
    return GeodataDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .category_id
        .equals(category_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plColumnDBModels', 'plField2'..]) or so on..
  List<ColumnDBModel>? plColumnDBModels;

  /// get ColumnDBModel(s) filtered by category_id=category_id
  ColumnDBModelFilterBuilder? getColumnDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (category_id == null) {
      return null;
    }
    return ColumnDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .category_id
        .equals(category_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (CategoryDBModel)

  static const bool _softDeleteActivated = false;
  CategoryDBModelManager? __mnCategoryDBModel;

  CategoryDBModelManager get _mnCategoryDBModel {
    return __mnCategoryDBModel =
        __mnCategoryDBModel ?? CategoryDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (category_id != null) {
      map['category_id'] = category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (icon != null) {
      map['icon'] = icon;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (category_id != null) {
      map['category_id'] = category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (icon != null) {
      map['icon'] = icon;
    }

// COLLECTIONS (CategoryDBModel)
    if (!forQuery) {
      map['GeodataDBModels'] = await getGeodataDBModels()!.toMapList();
    }
    if (!forQuery) {
      map['ColumnDBModels'] = await getColumnDBModels()!.toMapList();
    }
// END COLLECTIONS (CategoryDBModel)

    return map;
  }

  /// This method returns Json String [CategoryDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CategoryDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, description, color, icon];
  }

  List<dynamic> toArgsWithIds() {
    return [category_id, name, description, color, icon];
  }

  static Future<List<CategoryDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR CategoryDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CategoryDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CategoryDBModel>[];
    try {
      objList = list
          .map((categorydbmodel) =>
              CategoryDBModel.fromMap(categorydbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR CategoryDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CategoryDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CategoryDBModel> objList = <CategoryDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CategoryDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plGeodataDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plGeodataDBModels'))) {
          /*_loadedfields!.add('Category.plGeodataDBModels'); */ obj
                  .plGeodataDBModels =
              obj.plGeodataDBModels ??
                  await obj.getGeodataDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Category.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('Category.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns CategoryDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? category_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns CategoryDBModel if exist, otherwise returns null
  Future<CategoryDBModel?> getById(int? category_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (category_id == null) {
      return null;
    }
    CategoryDBModel? obj;
    final data = await _mnCategoryDBModel.getById([category_id]);
    if (data.length != 0) {
      obj = CategoryDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plGeodataDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plGeodataDBModels'))) {
          /*_loadedfields!.add('Category.plGeodataDBModels'); */ obj
                  .plGeodataDBModels =
              obj.plGeodataDBModels ??
                  await obj.getGeodataDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Category.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('Category.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CategoryDBModel) object. If the category_id field is null, saves as a new record and returns new category_id, if category_id is not null then updates record

  /// <returns>Returns category_id
  Future<int?> save() async {
    if (category_id == null || category_id == 0) {
      category_id = await _mnCategoryDBModel.insert(this);
    } else {
      // category_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCategoryDBModel.update(this);
    }

    return category_id;
  }

  /// saveAs CategoryDBModel. Returns a new Primary Key value of CategoryDBModel

  /// <returns>Returns a new Primary Key value of CategoryDBModel
  Future<int?> saveAs() async {
    category_id = null;

    return save();
  }

  /// saveAll method saves the sent List<CategoryDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<CategoryDBModel> categorydbmodels) async {
    // final results = _mnCategoryDBModel.saveAll('INSERT OR REPLACE INTO Category (category_id,name, description, color, icon)  VALUES (?,?,?,?,?)',categorydbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in categorydbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < categorydbmodels.length; i++) {
      if (categorydbmodels[i].category_id == null) {
        categorydbmodels[i].category_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns category_id

  Future<int?> upsert() async {
    try {
      final result = await _mnCategoryDBModel.rawInsert(
          'INSERT OR REPLACE INTO Category (category_id,name, description, color, icon)  VALUES (?,?,?,?,?)',
          [category_id, name, description, color, icon]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CategoryDBModel category_id=$category_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'CategoryDBModel category_id=$category_id did not update');
      }
      return category_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CategoryDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CategoryDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<CategoryDBModel> categorydbmodels) async {
    final results = await _mnCategoryDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO Category (category_id,name, description, color, icon)  VALUES (?,?,?,?,?)',
        categorydbmodels);
    return results;
  }

  /// Deletes CategoryDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete CategoryDBModel invoked (category_id=$category_id)');
    var result = BoolResult(success: false);
    {
      result = await GeodataDBModel()
          .select()
          .category_id
          .equals(category_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await ColumnDBModel()
          .select()
          .category_id
          .equals(category_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnCategoryDBModel.delete(QueryParams(
          whereString: 'category_id=?', whereArguments: [category_id]));
    } else {
      return _mnCategoryDBModel.updateBatch(
          QueryParams(
              whereString: 'category_id=?', whereArguments: [category_id]),
          {'isDeleted': 1});
    }
  }

  CategoryDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  CategoryDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion categorydbmodel

// region CategoryDBModelField
class CategoryDBModelField extends SearchCriteria {
  CategoryDBModelField(this.categorydbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  CategoryDBModelFilterBuilder categorydbmodelFB;

  CategoryDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  CategoryDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.EQuals, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder isNull() {
    categorydbmodelFB._addedBlocks = setCriteria(
        0,
        categorydbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      categorydbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          categorydbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categorydbmodelFB._addedBlocks);
      _waitingNot = '';
      categorydbmodelFB
              ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
          categorydbmodelFB._addedBlocks.retVal;
    }
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      categorydbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          categorydbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categorydbmodelFB._addedBlocks);
      _waitingNot = '';
      categorydbmodelFB
              ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
          categorydbmodelFB._addedBlocks.retVal;
      categorydbmodelFB
              ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
          categorydbmodelFB._addedBlocks.retVal;
    }
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      categorydbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          categorydbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categorydbmodelFB._addedBlocks);
      _waitingNot = '';
      categorydbmodelFB
              ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
          categorydbmodelFB._addedBlocks.retVal;
    }
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      categorydbmodelFB._addedBlocks = setCriteria(
          pFirst,
          categorydbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categorydbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        categorydbmodelFB._addedBlocks = setCriteria(
            pFirst,
            categorydbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            categorydbmodelFB._addedBlocks);
      } else {
        categorydbmodelFB._addedBlocks = setCriteria(
            pFirst,
            categorydbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            categorydbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        categorydbmodelFB._addedBlocks = setCriteria(
            pLast,
            categorydbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            categorydbmodelFB._addedBlocks);
      } else {
        categorydbmodelFB._addedBlocks = setCriteria(
            pLast,
            categorydbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            categorydbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.LessThan, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.LessThan, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    categorydbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, categorydbmodelFB._addedBlocks)
        : setCriteria(pValue, categorydbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }

  CategoryDBModelFilterBuilder inValues(dynamic pValue) {
    categorydbmodelFB._addedBlocks = setCriteria(
        pValue,
        categorydbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        categorydbmodelFB._addedBlocks);
    _waitingNot = '';
    categorydbmodelFB
            ._addedBlocks.needEndBlock![categorydbmodelFB._blockIndex] =
        categorydbmodelFB._addedBlocks.retVal;
    return categorydbmodelFB;
  }
}
// endregion CategoryDBModelField

// region CategoryDBModelFilterBuilder
class CategoryDBModelFilterBuilder extends SearchCriteria {
  CategoryDBModelFilterBuilder(CategoryDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  CategoryDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  CategoryDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  CategoryDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  CategoryDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  CategoryDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  CategoryDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  CategoryDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  CategoryDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CategoryDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CategoryDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CategoryDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CategoryDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  CategoryDBModelField setField(
      CategoryDBModelField? field, String colName, DbType dbtype) {
    return CategoryDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  CategoryDBModelField? _category_id;
  CategoryDBModelField get category_id {
    return _category_id = setField(_category_id, 'category_id', DbType.integer);
  }

  CategoryDBModelField? _name;
  CategoryDBModelField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  CategoryDBModelField? _description;
  CategoryDBModelField get description {
    return _description = setField(_description, 'description', DbType.text);
  }

  CategoryDBModelField? _color;
  CategoryDBModelField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  CategoryDBModelField? _icon;
  CategoryDBModelField get icon {
    return _icon = setField(_icon, 'icon', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (CategoryDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<CategoryDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (GeodataDBModel) according to DeleteRule.CASCADE
    final idListGeodataDBModelBYcategory_id = toListPrimaryKeySQL(false);
    final resGeodataDBModelBYcategory_id = await GeodataDBModel()
        .select()
        .where('category_id IN (${idListGeodataDBModelBYcategory_id['sql']})',
            parameterValue: idListGeodataDBModelBYcategory_id['args'])
        .delete(hardDelete);
    if (!resGeodataDBModelBYcategory_id.success) {
      return resGeodataDBModelBYcategory_id;
    }
// Delete sub records where in (ColumnDBModel) according to DeleteRule.CASCADE
    final idListColumnDBModelBYcategory_id = toListPrimaryKeySQL(false);
    final resColumnDBModelBYcategory_id = await ColumnDBModel()
        .select()
        .where('category_id IN (${idListColumnDBModelBYcategory_id['sql']})',
            parameterValue: idListColumnDBModelBYcategory_id['args'])
        .delete(hardDelete);
    if (!resColumnDBModelBYcategory_id.success) {
      return resColumnDBModelBYcategory_id;
    }

    if (CategoryDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnCategoryDBModel.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnCategoryDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'category_id IN (SELECT category_id from Category ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnCategoryDBModel.updateBatch(qparams, values);
  }

  /// This method always returns CategoryDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<CategoryDBModel>
  Future<CategoryDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnCategoryDBModel.toList(qparams);
    final data = await objFuture;
    CategoryDBModel? obj;
    if (data.isNotEmpty) {
      obj = CategoryDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plGeodataDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plGeodataDBModels'))) {
          /*_loadedfields!.add('Category.plGeodataDBModels'); */ obj
                  .plGeodataDBModels =
              obj.plGeodataDBModels ??
                  await obj.getGeodataDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Category.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('Category.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [CategoryDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? categorydbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final categorydbmodelsFuture =
        await _obj!._mnCategoryDBModel.toList(qparams);
    final int count = categorydbmodelsFuture[0]['CNT'] as int;
    if (categorydbmodelCount != null) {
      categorydbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<CategoryDBModel> [CategoryDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<CategoryDBModel>
  Future<List<CategoryDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CategoryDBModel> categorydbmodelsData =
        await CategoryDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return categorydbmodelsData;
  }

  /// This method returns Json String [CategoryDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CategoryDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CategoryDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnCategoryDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CategoryDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `category_id` FROM Category WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> category_idData = <int>[];
    qparams.selectColumns = ['category_id'];
    final category_idFuture = await _obj!._mnCategoryDBModel.toList(qparams);

    final int count = category_idFuture.length;
    for (int i = 0; i < count; i++) {
      category_idData.add(category_idFuture[i]['category_id'] as int);
    }
    return category_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CategoryDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnCategoryDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await CategoryDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnCategoryDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CategoryDBModelFilterBuilder

// region CategoryDBModelFields
class CategoryDBModelFields {
  static TableField? _fCategory_id;
  static TableField get category_id {
    return _fCategory_id = _fCategory_id ??
        SqlSyntax.setField(_fCategory_id, 'category_id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField? _fIcon;
  static TableField get icon {
    return _fIcon =
        _fIcon ?? SqlSyntax.setField(_fIcon, 'icon', DbType.integer);
  }
}
// endregion CategoryDBModelFields

//region CategoryDBModelManager
class CategoryDBModelManager extends SqfEntityProvider {
  CategoryDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Category';
  static final List<String> _primaryKeyList = ['category_id'];
  static final String _whereStr = 'category_id=?';
}

//endregion CategoryDBModelManager
// region GeodataDBModel
class GeodataDBModel {
  GeodataDBModel(
      {this.geodata_id, this.longitude, this.latitude, this.category_id}) {
    _setDefaultValues();
  }
  GeodataDBModel.withFields(this.longitude, this.latitude, this.category_id) {
    _setDefaultValues();
  }
  GeodataDBModel.withId(
      this.geodata_id, this.longitude, this.latitude, this.category_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  GeodataDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    geodata_id = int.tryParse(o['geodata_id'].toString());
    if (o['longitude'] != null) {
      longitude = double.tryParse(o['longitude'].toString());
    }
    if (o['latitude'] != null) {
      latitude = double.tryParse(o['latitude'].toString());
    }
    category_id = int.tryParse(o['category_id'].toString());

    // RELATIONSHIPS FromMAP
    plCategoryDBModel = o['categoryDBModel'] != null
        ? CategoryDBModel.fromMap(o['categoryDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (GeodataDBModel)
  int? geodata_id;
  double? longitude;
  double? latitude;
  int? category_id;

  BoolResult? saveResult;
  // end FIELDS (GeodataDBModel)

// RELATIONSHIPS (GeodataDBModel)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCategoryDBModel', 'plField2'..]) or so on..
  CategoryDBModel? plCategoryDBModel;

  /// get CategoryDBModel By Category_id
  Future<CategoryDBModel?> getCategoryDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await CategoryDBModel().getById(category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (GeodataDBModel)

// COLLECTIONS & VIRTUALS (GeodataDBModel)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldValueDBModels', 'plField2'..]) or so on..
  List<FieldValueDBModel>? plFieldValueDBModels;

  /// get FieldValueDBModel(s) filtered by geodata_id=geodata_id
  FieldValueDBModelFilterBuilder? getFieldValueDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (geodata_id == null) {
      return null;
    }
    return FieldValueDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .geodata_id
        .equals(geodata_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVMarkers', 'plField2'..]) or so on..
  List<VMarker>? plVMarkers;

  /// get VMarker(s) filtered by geodata_id=geodata_id
  VMarkerFilterBuilder? getVMarkers(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (geodata_id == null) {
      return null;
    }
    return VMarker()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .geodata_id
        .equals(geodata_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (GeodataDBModel)

  static const bool _softDeleteActivated = false;
  GeodataDBModelManager? __mnGeodataDBModel;

  GeodataDBModelManager get _mnGeodataDBModel {
    return __mnGeodataDBModel = __mnGeodataDBModel ?? GeodataDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (geodata_id != null) {
      map['geodata_id'] = geodata_id;
    }
    if (longitude != null) {
      map['longitude'] = longitude;
    }

    if (latitude != null) {
      map['latitude'] = latitude;
    }

    if (category_id != null) {
      map['category_id'] = forView
          ? plCategoryDBModel == null
              ? category_id
              : plCategoryDBModel!.name
          : category_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (geodata_id != null) {
      map['geodata_id'] = geodata_id;
    }
    if (longitude != null) {
      map['longitude'] = longitude;
    }

    if (latitude != null) {
      map['latitude'] = latitude;
    }

    if (category_id != null) {
      map['category_id'] = forView
          ? plCategoryDBModel == null
              ? category_id
              : plCategoryDBModel!.name
          : category_id;
    }

// COLLECTIONS (GeodataDBModel)
    if (!forQuery) {
      map['FieldValueDBModels'] = await getFieldValueDBModels()!.toMapList();
    }
    if (!forQuery) {
      map['VMarkers'] = await getVMarkers()!.toMapList();
    }
// END COLLECTIONS (GeodataDBModel)

    return map;
  }

  /// This method returns Json String [GeodataDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [GeodataDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [longitude, latitude, category_id];
  }

  List<dynamic> toArgsWithIds() {
    return [geodata_id, longitude, latitude, category_id];
  }

  static Future<List<GeodataDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR GeodataDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<GeodataDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <GeodataDBModel>[];
    try {
      objList = list
          .map((geodatadbmodel) =>
              GeodataDBModel.fromMap(geodatadbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR GeodataDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<GeodataDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<GeodataDBModel> objList = <GeodataDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = GeodataDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('Geodata.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Geodata.plVMarkers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVMarkers'))) {
          /*_loadedfields!.add('Geodata.plVMarkers'); */ obj.plVMarkers =
              obj.plVMarkers ??
                  await obj.getVMarkers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns GeodataDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? geodata_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns GeodataDBModel if exist, otherwise returns null
  Future<GeodataDBModel?> getById(int? geodata_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (geodata_id == null) {
      return null;
    }
    GeodataDBModel? obj;
    final data = await _mnGeodataDBModel.getById([geodata_id]);
    if (data.length != 0) {
      obj = GeodataDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('Geodata.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Geodata.plVMarkers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVMarkers'))) {
          /*_loadedfields!.add('Geodata.plVMarkers'); */ obj.plVMarkers =
              obj.plVMarkers ??
                  await obj.getVMarkers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (GeodataDBModel) object. If the geodata_id field is null, saves as a new record and returns new geodata_id, if geodata_id is not null then updates record

  /// <returns>Returns geodata_id
  Future<int?> save() async {
    if (geodata_id == null || geodata_id == 0) {
      geodata_id = await _mnGeodataDBModel.insert(this);
    } else {
      // geodata_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnGeodataDBModel.update(this);
    }

    return geodata_id;
  }

  /// saveAs GeodataDBModel. Returns a new Primary Key value of GeodataDBModel

  /// <returns>Returns a new Primary Key value of GeodataDBModel
  Future<int?> saveAs() async {
    geodata_id = null;

    return save();
  }

  /// saveAll method saves the sent List<GeodataDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<GeodataDBModel> geodatadbmodels) async {
    // final results = _mnGeodataDBModel.saveAll('INSERT OR REPLACE INTO Geodata (geodata_id,longitude, latitude, category_id)  VALUES (?,?,?,?)',geodatadbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in geodatadbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < geodatadbmodels.length; i++) {
      if (geodatadbmodels[i].geodata_id == null) {
        geodatadbmodels[i].geodata_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns geodata_id

  Future<int?> upsert() async {
    try {
      final result = await _mnGeodataDBModel.rawInsert(
          'INSERT OR REPLACE INTO Geodata (geodata_id,longitude, latitude, category_id)  VALUES (?,?,?,?)',
          [geodata_id, longitude, latitude, category_id]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'GeodataDBModel geodata_id=$geodata_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'GeodataDBModel geodata_id=$geodata_id did not update');
      }
      return geodata_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'GeodataDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<GeodataDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<GeodataDBModel> geodatadbmodels) async {
    final results = await _mnGeodataDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO Geodata (geodata_id,longitude, latitude, category_id)  VALUES (?,?,?,?)',
        geodatadbmodels);
    return results;
  }

  /// Deletes GeodataDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete GeodataDBModel invoked (geodata_id=$geodata_id)');
    var result = BoolResult(success: false);
    {
      result = await FieldValueDBModel()
          .select()
          .geodata_id
          .equals(geodata_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (await VMarker().select().geodata_id.equals(geodata_id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VMarker.geodata_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnGeodataDBModel.delete(QueryParams(
          whereString: 'geodata_id=?', whereArguments: [geodata_id]));
    } else {
      return _mnGeodataDBModel.updateBatch(
          QueryParams(
              whereString: 'geodata_id=?', whereArguments: [geodata_id]),
          {'isDeleted': 1});
    }
  }

  GeodataDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return GeodataDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  GeodataDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return GeodataDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion geodatadbmodel

// region GeodataDBModelField
class GeodataDBModelField extends SearchCriteria {
  GeodataDBModelField(this.geodatadbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  GeodataDBModelFilterBuilder geodatadbmodelFB;

  GeodataDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  GeodataDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.EQuals, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder isNull() {
    geodatadbmodelFB._addedBlocks = setCriteria(
        0,
        geodatadbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      geodatadbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          geodatadbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          geodatadbmodelFB._addedBlocks);
      _waitingNot = '';
      geodatadbmodelFB
              ._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
          geodatadbmodelFB._addedBlocks.retVal;
    }
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      geodatadbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          geodatadbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          geodatadbmodelFB._addedBlocks);
      _waitingNot = '';
      geodatadbmodelFB
              ._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
          geodatadbmodelFB._addedBlocks.retVal;
      geodatadbmodelFB
              ._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
          geodatadbmodelFB._addedBlocks.retVal;
    }
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      geodatadbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          geodatadbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          geodatadbmodelFB._addedBlocks);
      _waitingNot = '';
      geodatadbmodelFB
              ._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
          geodatadbmodelFB._addedBlocks.retVal;
    }
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      geodatadbmodelFB._addedBlocks = setCriteria(
          pFirst,
          geodatadbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          geodatadbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        geodatadbmodelFB._addedBlocks = setCriteria(
            pFirst,
            geodatadbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            geodatadbmodelFB._addedBlocks);
      } else {
        geodatadbmodelFB._addedBlocks = setCriteria(
            pFirst,
            geodatadbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            geodatadbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        geodatadbmodelFB._addedBlocks = setCriteria(
            pLast,
            geodatadbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            geodatadbmodelFB._addedBlocks);
      } else {
        geodatadbmodelFB._addedBlocks = setCriteria(
            pLast,
            geodatadbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            geodatadbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.LessThan, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.LessThan, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    geodatadbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, geodatadbmodelFB._addedBlocks)
        : setCriteria(pValue, geodatadbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }

  GeodataDBModelFilterBuilder inValues(dynamic pValue) {
    geodatadbmodelFB._addedBlocks = setCriteria(
        pValue,
        geodatadbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        geodatadbmodelFB._addedBlocks);
    _waitingNot = '';
    geodatadbmodelFB._addedBlocks.needEndBlock![geodatadbmodelFB._blockIndex] =
        geodatadbmodelFB._addedBlocks.retVal;
    return geodatadbmodelFB;
  }
}
// endregion GeodataDBModelField

// region GeodataDBModelFilterBuilder
class GeodataDBModelFilterBuilder extends SearchCriteria {
  GeodataDBModelFilterBuilder(GeodataDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  GeodataDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  GeodataDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  GeodataDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  GeodataDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  GeodataDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  GeodataDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  GeodataDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  GeodataDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  GeodataDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  GeodataDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  GeodataDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  GeodataDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  GeodataDBModelField setField(
      GeodataDBModelField? field, String colName, DbType dbtype) {
    return GeodataDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  GeodataDBModelField? _geodata_id;
  GeodataDBModelField get geodata_id {
    return _geodata_id = setField(_geodata_id, 'geodata_id', DbType.integer);
  }

  GeodataDBModelField? _longitude;
  GeodataDBModelField get longitude {
    return _longitude = setField(_longitude, 'longitude', DbType.real);
  }

  GeodataDBModelField? _latitude;
  GeodataDBModelField get latitude {
    return _latitude = setField(_latitude, 'latitude', DbType.real);
  }

  GeodataDBModelField? _category_id;
  GeodataDBModelField get category_id {
    return _category_id = setField(_category_id, 'category_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (GeodataDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<GeodataDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (FieldValueDBModel) according to DeleteRule.CASCADE
    final idListFieldValueDBModelBYgeodata_id = toListPrimaryKeySQL(false);
    final resFieldValueDBModelBYgeodata_id = await FieldValueDBModel()
        .select()
        .where('geodata_id IN (${idListFieldValueDBModelBYgeodata_id['sql']})',
            parameterValue: idListFieldValueDBModelBYgeodata_id['args'])
        .delete(hardDelete);
    if (!resFieldValueDBModelBYgeodata_id.success) {
      return resFieldValueDBModelBYgeodata_id;
    }
// Check sub records where in (VMarker) according to DeleteRule.NO_ACTION

    final idListVMarkerBYgeodata_id = toListPrimaryKeySQL(false);
    final resVMarkerBYgeodata_id = await VMarker()
        .select()
        .where('geodata_id IN (${idListVMarkerBYgeodata_id['sql']})',
            parameterValue: idListVMarkerBYgeodata_id['args'])
        .toCount();
    if (resVMarkerBYgeodata_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VMarker.geodata_id)');
    }

    if (GeodataDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnGeodataDBModel.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnGeodataDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'geodata_id IN (SELECT geodata_id from Geodata ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnGeodataDBModel.updateBatch(qparams, values);
  }

  /// This method always returns GeodataDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<GeodataDBModel>
  Future<GeodataDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnGeodataDBModel.toList(qparams);
    final data = await objFuture;
    GeodataDBModel? obj;
    if (data.isNotEmpty) {
      obj = GeodataDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('Geodata.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Geodata.plVMarkers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVMarkers'))) {
          /*_loadedfields!.add('Geodata.plVMarkers'); */ obj.plVMarkers =
              obj.plVMarkers ??
                  await obj.getVMarkers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [GeodataDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? geodatadbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final geodatadbmodelsFuture = await _obj!._mnGeodataDBModel.toList(qparams);
    final int count = geodatadbmodelsFuture[0]['CNT'] as int;
    if (geodatadbmodelCount != null) {
      geodatadbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<GeodataDBModel> [GeodataDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<GeodataDBModel>
  Future<List<GeodataDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<GeodataDBModel> geodatadbmodelsData =
        await GeodataDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return geodatadbmodelsData;
  }

  /// This method returns Json String [GeodataDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [GeodataDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [GeodataDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnGeodataDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [GeodataDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `geodata_id` FROM Geodata WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> geodata_idData = <int>[];
    qparams.selectColumns = ['geodata_id'];
    final geodata_idFuture = await _obj!._mnGeodataDBModel.toList(qparams);

    final int count = geodata_idFuture.length;
    for (int i = 0; i < count; i++) {
      geodata_idData.add(geodata_idFuture[i]['geodata_id'] as int);
    }
    return geodata_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [GeodataDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnGeodataDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await GeodataDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnGeodataDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion GeodataDBModelFilterBuilder

// region GeodataDBModelFields
class GeodataDBModelFields {
  static TableField? _fGeodata_id;
  static TableField get geodata_id {
    return _fGeodata_id = _fGeodata_id ??
        SqlSyntax.setField(_fGeodata_id, 'geodata_id', DbType.integer);
  }

  static TableField? _fLongitude;
  static TableField get longitude {
    return _fLongitude = _fLongitude ??
        SqlSyntax.setField(_fLongitude, 'longitude', DbType.real);
  }

  static TableField? _fLatitude;
  static TableField get latitude {
    return _fLatitude =
        _fLatitude ?? SqlSyntax.setField(_fLatitude, 'latitude', DbType.real);
  }

  static TableField? _fCategory_id;
  static TableField get category_id {
    return _fCategory_id = _fCategory_id ??
        SqlSyntax.setField(_fCategory_id, 'category_id', DbType.integer);
  }
}
// endregion GeodataDBModelFields

//region GeodataDBModelManager
class GeodataDBModelManager extends SqfEntityProvider {
  GeodataDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Geodata';
  static final List<String> _primaryKeyList = ['geodata_id'];
  static final String _whereStr = 'geodata_id=?';
}

//endregion GeodataDBModelManager
// region ColumnDBModel
class ColumnDBModel {
  ColumnDBModel(
      {this.column_id, this.name, this.category_id, this.field_type_id}) {
    _setDefaultValues();
  }
  ColumnDBModel.withFields(this.name, this.category_id, this.field_type_id) {
    _setDefaultValues();
  }
  ColumnDBModel.withId(
      this.column_id, this.name, this.category_id, this.field_type_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ColumnDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    column_id = int.tryParse(o['column_id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    category_id = int.tryParse(o['category_id'].toString());

    field_type_id = int.tryParse(o['field_type_id'].toString());

    // RELATIONSHIPS FromMAP
    plCategoryDBModel = o['categoryDBModel'] != null
        ? CategoryDBModel.fromMap(o['categoryDBModel'] as Map<String, dynamic>)
        : null;
    plFieldTypeDBModel = o['fieldTypeDBModel'] != null
        ? FieldTypeDBModel.fromMap(
            o['fieldTypeDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (ColumnDBModel)
  int? column_id;
  String? name;
  int? category_id;
  int? field_type_id;

  BoolResult? saveResult;
  // end FIELDS (ColumnDBModel)

// RELATIONSHIPS (ColumnDBModel)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCategoryDBModel', 'plField2'..]) or so on..
  CategoryDBModel? plCategoryDBModel;

  /// get CategoryDBModel By Category_id
  Future<CategoryDBModel?> getCategoryDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await CategoryDBModel().getById(category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldTypeDBModel', 'plField2'..]) or so on..
  FieldTypeDBModel? plFieldTypeDBModel;

  /// get FieldTypeDBModel By Field_type_id
  Future<FieldTypeDBModel?> getFieldTypeDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await FieldTypeDBModel().getById(field_type_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ColumnDBModel)

  static const bool _softDeleteActivated = false;
  ColumnDBModelManager? __mnColumnDBModel;

  ColumnDBModelManager get _mnColumnDBModel {
    return __mnColumnDBModel = __mnColumnDBModel ?? ColumnDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (column_id != null) {
      map['column_id'] = column_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (category_id != null) {
      map['category_id'] = forView
          ? plCategoryDBModel == null
              ? category_id
              : plCategoryDBModel!.name
          : category_id;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (column_id != null) {
      map['column_id'] = column_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (category_id != null) {
      map['category_id'] = forView
          ? plCategoryDBModel == null
              ? category_id
              : plCategoryDBModel!.name
          : category_id;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

    return map;
  }

  /// This method returns Json String [ColumnDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ColumnDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, category_id, field_type_id];
  }

  List<dynamic> toArgsWithIds() {
    return [column_id, name, category_id, field_type_id];
  }

  static Future<List<ColumnDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR ColumnDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ColumnDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ColumnDBModel>[];
    try {
      objList = list
          .map((columndbmodel) =>
              ColumnDBModel.fromMap(columndbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR ColumnDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ColumnDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ColumnDBModel> objList = <ColumnDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ColumnDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ColumnDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? column_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns ColumnDBModel if exist, otherwise returns null
  Future<ColumnDBModel?> getById(int? column_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (column_id == null) {
      return null;
    }
    ColumnDBModel? obj;
    final data = await _mnColumnDBModel.getById([column_id]);
    if (data.length != 0) {
      obj = ColumnDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ColumnDBModel) object. If the column_id field is null, saves as a new record and returns new column_id, if column_id is not null then updates record

  /// <returns>Returns column_id
  Future<int?> save() async {
    if (column_id == null || column_id == 0) {
      column_id = await _mnColumnDBModel.insert(this);
    } else {
      // column_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnColumnDBModel.update(this);
    }

    return column_id;
  }

  /// saveAs ColumnDBModel. Returns a new Primary Key value of ColumnDBModel

  /// <returns>Returns a new Primary Key value of ColumnDBModel
  Future<int?> saveAs() async {
    column_id = null;

    return save();
  }

  /// saveAll method saves the sent List<ColumnDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ColumnDBModel> columndbmodels) async {
    // final results = _mnColumnDBModel.saveAll('INSERT OR REPLACE INTO Column (column_id,name, category_id, field_type_id)  VALUES (?,?,?,?)',columndbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in columndbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < columndbmodels.length; i++) {
      if (columndbmodels[i].column_id == null) {
        columndbmodels[i].column_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns column_id

  Future<int?> upsert() async {
    try {
      final result = await _mnColumnDBModel.rawInsert(
          'INSERT OR REPLACE INTO Column (column_id,name, category_id, field_type_id)  VALUES (?,?,?,?)',
          [column_id, name, category_id, field_type_id]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ColumnDBModel column_id=$column_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ColumnDBModel column_id=$column_id did not update');
      }
      return column_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ColumnDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ColumnDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<ColumnDBModel> columndbmodels) async {
    final results = await _mnColumnDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO Column (column_id,name, category_id, field_type_id)  VALUES (?,?,?,?)',
        columndbmodels);
    return results;
  }

  /// Deletes ColumnDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete ColumnDBModel invoked (column_id=$column_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnColumnDBModel.delete(
          QueryParams(whereString: 'column_id=?', whereArguments: [column_id]));
    } else {
      return _mnColumnDBModel.updateBatch(
          QueryParams(whereString: 'column_id=?', whereArguments: [column_id]),
          {'isDeleted': 1});
    }
  }

  ColumnDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ColumnDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ColumnDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ColumnDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion columndbmodel

// region ColumnDBModelField
class ColumnDBModelField extends SearchCriteria {
  ColumnDBModelField(this.columndbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ColumnDBModelFilterBuilder columndbmodelFB;

  ColumnDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ColumnDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.EQuals, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder isNull() {
    columndbmodelFB._addedBlocks = setCriteria(
        0,
        columndbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      columndbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          columndbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          columndbmodelFB._addedBlocks);
      _waitingNot = '';
      columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
          columndbmodelFB._addedBlocks.retVal;
    }
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      columndbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          columndbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          columndbmodelFB._addedBlocks);
      _waitingNot = '';
      columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
          columndbmodelFB._addedBlocks.retVal;
      columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
          columndbmodelFB._addedBlocks.retVal;
    }
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      columndbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          columndbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          columndbmodelFB._addedBlocks);
      _waitingNot = '';
      columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
          columndbmodelFB._addedBlocks.retVal;
    }
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      columndbmodelFB._addedBlocks = setCriteria(
          pFirst,
          columndbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          columndbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        columndbmodelFB._addedBlocks = setCriteria(
            pFirst,
            columndbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            columndbmodelFB._addedBlocks);
      } else {
        columndbmodelFB._addedBlocks = setCriteria(
            pFirst,
            columndbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            columndbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        columndbmodelFB._addedBlocks = setCriteria(
            pLast,
            columndbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            columndbmodelFB._addedBlocks);
      } else {
        columndbmodelFB._addedBlocks = setCriteria(
            pLast,
            columndbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            columndbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.LessThan, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.LessThan, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    columndbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, columndbmodelFB._addedBlocks)
        : setCriteria(pValue, columndbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }

  ColumnDBModelFilterBuilder inValues(dynamic pValue) {
    columndbmodelFB._addedBlocks = setCriteria(
        pValue,
        columndbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        columndbmodelFB._addedBlocks);
    _waitingNot = '';
    columndbmodelFB._addedBlocks.needEndBlock![columndbmodelFB._blockIndex] =
        columndbmodelFB._addedBlocks.retVal;
    return columndbmodelFB;
  }
}
// endregion ColumnDBModelField

// region ColumnDBModelFilterBuilder
class ColumnDBModelFilterBuilder extends SearchCriteria {
  ColumnDBModelFilterBuilder(ColumnDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  ColumnDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ColumnDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ColumnDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ColumnDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ColumnDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ColumnDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ColumnDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ColumnDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ColumnDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ColumnDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ColumnDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ColumnDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ColumnDBModelField setField(
      ColumnDBModelField? field, String colName, DbType dbtype) {
    return ColumnDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ColumnDBModelField? _column_id;
  ColumnDBModelField get column_id {
    return _column_id = setField(_column_id, 'column_id', DbType.integer);
  }

  ColumnDBModelField? _name;
  ColumnDBModelField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  ColumnDBModelField? _category_id;
  ColumnDBModelField get category_id {
    return _category_id = setField(_category_id, 'category_id', DbType.integer);
  }

  ColumnDBModelField? _field_type_id;
  ColumnDBModelField get field_type_id {
    return _field_type_id =
        setField(_field_type_id, 'field_type_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (ColumnDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<ColumnDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (ColumnDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnColumnDBModel.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnColumnDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'column_id IN (SELECT column_id from Column ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnColumnDBModel.updateBatch(qparams, values);
  }

  /// This method always returns ColumnDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ColumnDBModel>
  Future<ColumnDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnColumnDBModel.toList(qparams);
    final data = await objFuture;
    ColumnDBModel? obj;
    if (data.isNotEmpty) {
      obj = ColumnDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Category.plCategoryDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCategoryDBModel'))) {
          /*_loadedfields!.add('Category.plCategoryDBModel');*/ obj
              .plCategoryDBModel = obj
                  .plCategoryDBModel ??
              await obj.getCategoryDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [ColumnDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? columndbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final columndbmodelsFuture = await _obj!._mnColumnDBModel.toList(qparams);
    final int count = columndbmodelsFuture[0]['CNT'] as int;
    if (columndbmodelCount != null) {
      columndbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<ColumnDBModel> [ColumnDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ColumnDBModel>
  Future<List<ColumnDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ColumnDBModel> columndbmodelsData =
        await ColumnDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return columndbmodelsData;
  }

  /// This method returns Json String [ColumnDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ColumnDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ColumnDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnColumnDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ColumnDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `column_id` FROM Column WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> column_idData = <int>[];
    qparams.selectColumns = ['column_id'];
    final column_idFuture = await _obj!._mnColumnDBModel.toList(qparams);

    final int count = column_idFuture.length;
    for (int i = 0; i < count; i++) {
      column_idData.add(column_idFuture[i]['column_id'] as int);
    }
    return column_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ColumnDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnColumnDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await ColumnDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnColumnDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ColumnDBModelFilterBuilder

// region ColumnDBModelFields
class ColumnDBModelFields {
  static TableField? _fColumn_id;
  static TableField get column_id {
    return _fColumn_id = _fColumn_id ??
        SqlSyntax.setField(_fColumn_id, 'column_id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fCategory_id;
  static TableField get category_id {
    return _fCategory_id = _fCategory_id ??
        SqlSyntax.setField(_fCategory_id, 'category_id', DbType.integer);
  }

  static TableField? _fField_type_id;
  static TableField get field_type_id {
    return _fField_type_id = _fField_type_id ??
        SqlSyntax.setField(_fField_type_id, 'field_type_id', DbType.integer);
  }
}
// endregion ColumnDBModelFields

//region ColumnDBModelManager
class ColumnDBModelManager extends SqfEntityProvider {
  ColumnDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Column';
  static final List<String> _primaryKeyList = ['column_id'];
  static final String _whereStr = 'column_id=?';
}

//endregion ColumnDBModelManager
// region FieldTypeDBModel
class FieldTypeDBModel {
  FieldTypeDBModel({this.field_type_id, this.name, this.meta_type}) {
    _setDefaultValues();
  }
  FieldTypeDBModel.withFields(this.name, this.meta_type) {
    _setDefaultValues();
  }
  FieldTypeDBModel.withId(this.field_type_id, this.name, this.meta_type) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FieldTypeDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    field_type_id = int.tryParse(o['field_type_id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['meta_type'] != null) {
      meta_type = o['meta_type'].toString();
    }
  }
  // FIELDS (FieldTypeDBModel)
  int? field_type_id;
  String? name;
  String? meta_type;

  BoolResult? saveResult;
  // end FIELDS (FieldTypeDBModel)

// COLLECTIONS & VIRTUALS (FieldTypeDBModel)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plColumnDBModels', 'plField2'..]) or so on..
  List<ColumnDBModel>? plColumnDBModels;

  /// get ColumnDBModel(s) filtered by field_type_id=field_type_id
  ColumnDBModelFilterBuilder? getColumnDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (field_type_id == null) {
      return null;
    }
    return ColumnDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .field_type_id
        .equals(field_type_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plStaticSelectionDBModels', 'plField2'..]) or so on..
  List<StaticSelectionDBModel>? plStaticSelectionDBModels;

  /// get StaticSelectionDBModel(s) filtered by field_type_id=field_type_id
  StaticSelectionDBModelFilterBuilder? getStaticSelectionDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (field_type_id == null) {
      return null;
    }
    return StaticSelectionDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .field_type_id
        .equals(field_type_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldValueDBModels', 'plField2'..]) or so on..
  List<FieldValueDBModel>? plFieldValueDBModels;

  /// get FieldValueDBModel(s) filtered by field_type_id=column_id
  FieldValueDBModelFilterBuilder? getFieldValueDBModels(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (field_type_id == null) {
      return null;
    }
    return FieldValueDBModel()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .column_id
        .equals(field_type_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVStaticSelections', 'plField2'..]) or so on..
  List<VStaticSelection>? plVStaticSelections;

  /// get VStaticSelection(s) filtered by field_type_id=field_type_id
  VStaticSelectionFilterBuilder? getVStaticSelections(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (field_type_id == null) {
      return null;
    }
    return VStaticSelection()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .field_type_id
        .equals(field_type_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (FieldTypeDBModel)

  static const bool _softDeleteActivated = false;
  FieldTypeDBModelManager? __mnFieldTypeDBModel;

  FieldTypeDBModelManager get _mnFieldTypeDBModel {
    return __mnFieldTypeDBModel =
        __mnFieldTypeDBModel ?? FieldTypeDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (field_type_id != null) {
      map['field_type_id'] = field_type_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (meta_type != null) {
      map['meta_type'] = meta_type;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (field_type_id != null) {
      map['field_type_id'] = field_type_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (meta_type != null) {
      map['meta_type'] = meta_type;
    }

// COLLECTIONS (FieldTypeDBModel)
    if (!forQuery) {
      map['ColumnDBModels'] = await getColumnDBModels()!.toMapList();
    }
    if (!forQuery) {
      map['StaticSelectionDBModels'] =
          await getStaticSelectionDBModels()!.toMapList();
    }
    if (!forQuery) {
      map['FieldValueDBModels'] = await getFieldValueDBModels()!.toMapList();
    }
    if (!forQuery) {
      map['VStaticSelections'] = await getVStaticSelections()!.toMapList();
    }
// END COLLECTIONS (FieldTypeDBModel)

    return map;
  }

  /// This method returns Json String [FieldTypeDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FieldTypeDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, meta_type];
  }

  List<dynamic> toArgsWithIds() {
    return [field_type_id, name, meta_type];
  }

  static Future<List<FieldTypeDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR FieldTypeDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FieldTypeDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FieldTypeDBModel>[];
    try {
      objList = list
          .map((fieldtypedbmodel) => FieldTypeDBModel.fromMap(
              fieldtypedbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR FieldTypeDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FieldTypeDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FieldTypeDBModel> objList = <FieldTypeDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FieldTypeDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('FieldType.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plStaticSelectionDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStaticSelectionDBModels'))) {
          /*_loadedfields!.add('FieldType.plStaticSelectionDBModels'); */ obj
                  .plStaticSelectionDBModels =
              obj.plStaticSelectionDBModels ??
                  await obj.getStaticSelectionDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('FieldType.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('FieldType.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FieldTypeDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? field_type_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns FieldTypeDBModel if exist, otherwise returns null
  Future<FieldTypeDBModel?> getById(int? field_type_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (field_type_id == null) {
      return null;
    }
    FieldTypeDBModel? obj;
    final data = await _mnFieldTypeDBModel.getById([field_type_id]);
    if (data.length != 0) {
      obj = FieldTypeDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('FieldType.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plStaticSelectionDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStaticSelectionDBModels'))) {
          /*_loadedfields!.add('FieldType.plStaticSelectionDBModels'); */ obj
                  .plStaticSelectionDBModels =
              obj.plStaticSelectionDBModels ??
                  await obj.getStaticSelectionDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('FieldType.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('FieldType.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FieldTypeDBModel) object. If the field_type_id field is null, saves as a new record and returns new field_type_id, if field_type_id is not null then updates record

  /// <returns>Returns field_type_id
  Future<int?> save() async {
    if (field_type_id == null || field_type_id == 0) {
      field_type_id = await _mnFieldTypeDBModel.insert(this);
    } else {
      // field_type_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFieldTypeDBModel.update(this);
    }

    return field_type_id;
  }

  /// saveAs FieldTypeDBModel. Returns a new Primary Key value of FieldTypeDBModel

  /// <returns>Returns a new Primary Key value of FieldTypeDBModel
  Future<int?> saveAs() async {
    field_type_id = null;

    return save();
  }

  /// saveAll method saves the sent List<FieldTypeDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<FieldTypeDBModel> fieldtypedbmodels) async {
    // final results = _mnFieldTypeDBModel.saveAll('INSERT OR REPLACE INTO FieldType (field_type_id,name, meta_type)  VALUES (?,?,?)',fieldtypedbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in fieldtypedbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < fieldtypedbmodels.length; i++) {
      if (fieldtypedbmodels[i].field_type_id == null) {
        fieldtypedbmodels[i].field_type_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns field_type_id

  Future<int?> upsert() async {
    try {
      final result = await _mnFieldTypeDBModel.rawInsert(
          'INSERT OR REPLACE INTO FieldType (field_type_id,name, meta_type)  VALUES (?,?,?)',
          [field_type_id, name, meta_type]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FieldTypeDBModel field_type_id=$field_type_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FieldTypeDBModel field_type_id=$field_type_id did not update');
      }
      return field_type_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FieldTypeDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FieldTypeDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<FieldTypeDBModel> fieldtypedbmodels) async {
    final results = await _mnFieldTypeDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO FieldType (field_type_id,name, meta_type)  VALUES (?,?,?)',
        fieldtypedbmodels);
    return results;
  }

  /// Deletes FieldTypeDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete FieldTypeDBModel invoked (field_type_id=$field_type_id)');
    var result = BoolResult(success: false);
    {
      result = await ColumnDBModel()
          .select()
          .field_type_id
          .equals(field_type_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await StaticSelectionDBModel()
          .select()
          .field_type_id
          .equals(field_type_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await FieldValueDBModel()
          .select()
          .column_id
          .equals(field_type_id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (await VStaticSelection()
            .select()
            .field_type_id
            .equals(field_type_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VStaticSelection.field_type_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnFieldTypeDBModel.delete(QueryParams(
          whereString: 'field_type_id=?', whereArguments: [field_type_id]));
    } else {
      return _mnFieldTypeDBModel.updateBatch(
          QueryParams(
              whereString: 'field_type_id=?', whereArguments: [field_type_id]),
          {'isDeleted': 1});
    }
  }

  FieldTypeDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FieldTypeDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FieldTypeDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FieldTypeDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion fieldtypedbmodel

// region FieldTypeDBModelField
class FieldTypeDBModelField extends SearchCriteria {
  FieldTypeDBModelField(this.fieldtypedbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  FieldTypeDBModelFilterBuilder fieldtypedbmodelFB;

  FieldTypeDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FieldTypeDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.EQuals, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder isNull() {
    fieldtypedbmodelFB._addedBlocks = setCriteria(
        0,
        fieldtypedbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fieldtypedbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fieldtypedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldtypedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldtypedbmodelFB
              ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
          fieldtypedbmodelFB._addedBlocks.retVal;
    }
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fieldtypedbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fieldtypedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldtypedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldtypedbmodelFB
              ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
          fieldtypedbmodelFB._addedBlocks.retVal;
      fieldtypedbmodelFB
              ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
          fieldtypedbmodelFB._addedBlocks.retVal;
    }
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fieldtypedbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fieldtypedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldtypedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldtypedbmodelFB
              ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
          fieldtypedbmodelFB._addedBlocks.retVal;
    }
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fieldtypedbmodelFB._addedBlocks = setCriteria(
          pFirst,
          fieldtypedbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldtypedbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fieldtypedbmodelFB._addedBlocks = setCriteria(
            pFirst,
            fieldtypedbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            fieldtypedbmodelFB._addedBlocks);
      } else {
        fieldtypedbmodelFB._addedBlocks = setCriteria(
            pFirst,
            fieldtypedbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            fieldtypedbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fieldtypedbmodelFB._addedBlocks = setCriteria(
            pLast,
            fieldtypedbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            fieldtypedbmodelFB._addedBlocks);
      } else {
        fieldtypedbmodelFB._addedBlocks = setCriteria(
            pLast,
            fieldtypedbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            fieldtypedbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.LessThan, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.LessThan, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fieldtypedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fieldtypedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldtypedbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }

  FieldTypeDBModelFilterBuilder inValues(dynamic pValue) {
    fieldtypedbmodelFB._addedBlocks = setCriteria(
        pValue,
        fieldtypedbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fieldtypedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldtypedbmodelFB
            ._addedBlocks.needEndBlock![fieldtypedbmodelFB._blockIndex] =
        fieldtypedbmodelFB._addedBlocks.retVal;
    return fieldtypedbmodelFB;
  }
}
// endregion FieldTypeDBModelField

// region FieldTypeDBModelFilterBuilder
class FieldTypeDBModelFilterBuilder extends SearchCriteria {
  FieldTypeDBModelFilterBuilder(FieldTypeDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  FieldTypeDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  FieldTypeDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FieldTypeDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FieldTypeDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FieldTypeDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FieldTypeDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FieldTypeDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FieldTypeDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FieldTypeDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FieldTypeDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FieldTypeDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FieldTypeDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FieldTypeDBModelField setField(
      FieldTypeDBModelField? field, String colName, DbType dbtype) {
    return FieldTypeDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  FieldTypeDBModelField? _field_type_id;
  FieldTypeDBModelField get field_type_id {
    return _field_type_id =
        setField(_field_type_id, 'field_type_id', DbType.integer);
  }

  FieldTypeDBModelField? _name;
  FieldTypeDBModelField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  FieldTypeDBModelField? _meta_type;
  FieldTypeDBModelField get meta_type {
    return _meta_type = setField(_meta_type, 'meta_type', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (FieldTypeDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<FieldTypeDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (ColumnDBModel) according to DeleteRule.CASCADE
    final idListColumnDBModelBYfield_type_id = toListPrimaryKeySQL(false);
    final resColumnDBModelBYfield_type_id = await ColumnDBModel()
        .select()
        .where(
            'field_type_id IN (${idListColumnDBModelBYfield_type_id['sql']})',
            parameterValue: idListColumnDBModelBYfield_type_id['args'])
        .delete(hardDelete);
    if (!resColumnDBModelBYfield_type_id.success) {
      return resColumnDBModelBYfield_type_id;
    }
// Delete sub records where in (StaticSelectionDBModel) according to DeleteRule.CASCADE
    final idListStaticSelectionDBModelBYfield_type_id =
        toListPrimaryKeySQL(false);
    final resStaticSelectionDBModelBYfield_type_id = await StaticSelectionDBModel()
        .select()
        .where(
            'field_type_id IN (${idListStaticSelectionDBModelBYfield_type_id['sql']})',
            parameterValue: idListStaticSelectionDBModelBYfield_type_id['args'])
        .delete(hardDelete);
    if (!resStaticSelectionDBModelBYfield_type_id.success) {
      return resStaticSelectionDBModelBYfield_type_id;
    }
// Delete sub records where in (FieldValueDBModel) according to DeleteRule.CASCADE
    final idListFieldValueDBModelBYcolumn_id = toListPrimaryKeySQL(false);
    final resFieldValueDBModelBYcolumn_id = await FieldValueDBModel()
        .select()
        .where('column_id IN (${idListFieldValueDBModelBYcolumn_id['sql']})',
            parameterValue: idListFieldValueDBModelBYcolumn_id['args'])
        .delete(hardDelete);
    if (!resFieldValueDBModelBYcolumn_id.success) {
      return resFieldValueDBModelBYcolumn_id;
    }
// Check sub records where in (VStaticSelection) according to DeleteRule.NO_ACTION

    final idListVStaticSelectionBYfield_type_id = toListPrimaryKeySQL(false);
    final resVStaticSelectionBYfield_type_id = await VStaticSelection()
        .select()
        .where(
            'field_type_id IN (${idListVStaticSelectionBYfield_type_id['sql']})',
            parameterValue: idListVStaticSelectionBYfield_type_id['args'])
        .toCount();
    if (resVStaticSelectionBYfield_type_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VStaticSelection.field_type_id)');
    }

    if (FieldTypeDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnFieldTypeDBModel
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnFieldTypeDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'field_type_id IN (SELECT field_type_id from FieldType ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnFieldTypeDBModel.updateBatch(qparams, values);
  }

  /// This method always returns FieldTypeDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FieldTypeDBModel>
  Future<FieldTypeDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnFieldTypeDBModel.toList(qparams);
    final data = await objFuture;
    FieldTypeDBModel? obj;
    if (data.isNotEmpty) {
      obj = FieldTypeDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plColumnDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plColumnDBModels'))) {
          /*_loadedfields!.add('FieldType.plColumnDBModels'); */ obj
                  .plColumnDBModels =
              obj.plColumnDBModels ??
                  await obj.getColumnDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plStaticSelectionDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plStaticSelectionDBModels'))) {
          /*_loadedfields!.add('FieldType.plStaticSelectionDBModels'); */ obj
                  .plStaticSelectionDBModels =
              obj.plStaticSelectionDBModels ??
                  await obj.getStaticSelectionDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldValueDBModels') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFieldValueDBModels'))) {
          /*_loadedfields!.add('FieldType.plFieldValueDBModels'); */ obj
                  .plFieldValueDBModels =
              obj.plFieldValueDBModels ??
                  await obj.getFieldValueDBModels()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('FieldType.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [FieldTypeDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? fieldtypedbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fieldtypedbmodelsFuture =
        await _obj!._mnFieldTypeDBModel.toList(qparams);
    final int count = fieldtypedbmodelsFuture[0]['CNT'] as int;
    if (fieldtypedbmodelCount != null) {
      fieldtypedbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<FieldTypeDBModel> [FieldTypeDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FieldTypeDBModel>
  Future<List<FieldTypeDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FieldTypeDBModel> fieldtypedbmodelsData =
        await FieldTypeDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return fieldtypedbmodelsData;
  }

  /// This method returns Json String [FieldTypeDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FieldTypeDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FieldTypeDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnFieldTypeDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FieldTypeDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `field_type_id` FROM FieldType WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> field_type_idData = <int>[];
    qparams.selectColumns = ['field_type_id'];
    final field_type_idFuture = await _obj!._mnFieldTypeDBModel.toList(qparams);

    final int count = field_type_idFuture.length;
    for (int i = 0; i < count; i++) {
      field_type_idData.add(field_type_idFuture[i]['field_type_id'] as int);
    }
    return field_type_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FieldTypeDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnFieldTypeDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await FieldTypeDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnFieldTypeDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FieldTypeDBModelFilterBuilder

// region FieldTypeDBModelFields
class FieldTypeDBModelFields {
  static TableField? _fField_type_id;
  static TableField get field_type_id {
    return _fField_type_id = _fField_type_id ??
        SqlSyntax.setField(_fField_type_id, 'field_type_id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fMeta_type;
  static TableField get meta_type {
    return _fMeta_type = _fMeta_type ??
        SqlSyntax.setField(_fMeta_type, 'meta_type', DbType.text);
  }
}
// endregion FieldTypeDBModelFields

//region FieldTypeDBModelManager
class FieldTypeDBModelManager extends SqfEntityProvider {
  FieldTypeDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'FieldType';
  static final List<String> _primaryKeyList = ['field_type_id'];
  static final String _whereStr = 'field_type_id=?';
}

//endregion FieldTypeDBModelManager
// region StaticSelectionDBModel
class StaticSelectionDBModel {
  StaticSelectionDBModel(
      {this.static_selection_id, this.options, this.field_type_id}) {
    _setDefaultValues();
  }
  StaticSelectionDBModel.withFields(this.options, this.field_type_id) {
    _setDefaultValues();
  }
  StaticSelectionDBModel.withId(
      this.static_selection_id, this.options, this.field_type_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  StaticSelectionDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    static_selection_id = int.tryParse(o['static_selection_id'].toString());
    if (o['options'] != null) {
      options = o['options'].toString();
    }
    field_type_id = int.tryParse(o['field_type_id'].toString());

    // RELATIONSHIPS FromMAP
    plFieldTypeDBModel = o['fieldTypeDBModel'] != null
        ? FieldTypeDBModel.fromMap(
            o['fieldTypeDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (StaticSelectionDBModel)
  int? static_selection_id;
  String? options;
  int? field_type_id;

  BoolResult? saveResult;
  // end FIELDS (StaticSelectionDBModel)

// RELATIONSHIPS (StaticSelectionDBModel)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldTypeDBModel', 'plField2'..]) or so on..
  FieldTypeDBModel? plFieldTypeDBModel;

  /// get FieldTypeDBModel By Field_type_id
  Future<FieldTypeDBModel?> getFieldTypeDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await FieldTypeDBModel().getById(field_type_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (StaticSelectionDBModel)

// COLLECTIONS & VIRTUALS (StaticSelectionDBModel)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVStaticSelections', 'plField2'..]) or so on..
  List<VStaticSelection>? plVStaticSelections;

  /// get VStaticSelection(s) filtered by static_selection_id=static_selection_id
  VStaticSelectionFilterBuilder? getVStaticSelections(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (static_selection_id == null) {
      return null;
    }
    return VStaticSelection()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .static_selection_id
        .equals(static_selection_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (StaticSelectionDBModel)

  static const bool _softDeleteActivated = false;
  StaticSelectionDBModelManager? __mnStaticSelectionDBModel;

  StaticSelectionDBModelManager get _mnStaticSelectionDBModel {
    return __mnStaticSelectionDBModel =
        __mnStaticSelectionDBModel ?? StaticSelectionDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (static_selection_id != null) {
      map['static_selection_id'] = static_selection_id;
    }
    if (options != null) {
      map['options'] = options;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (static_selection_id != null) {
      map['static_selection_id'] = static_selection_id;
    }
    if (options != null) {
      map['options'] = options;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

// COLLECTIONS (StaticSelectionDBModel)
    if (!forQuery) {
      map['VStaticSelections'] = await getVStaticSelections()!.toMapList();
    }
// END COLLECTIONS (StaticSelectionDBModel)

    return map;
  }

  /// This method returns Json String [StaticSelectionDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [StaticSelectionDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [options, field_type_id];
  }

  List<dynamic> toArgsWithIds() {
    return [static_selection_id, options, field_type_id];
  }

  static Future<List<StaticSelectionDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR StaticSelectionDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<StaticSelectionDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <StaticSelectionDBModel>[];
    try {
      objList = list
          .map((staticselectiondbmodel) => StaticSelectionDBModel.fromMap(
              staticselectiondbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR StaticSelectionDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<StaticSelectionDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<StaticSelectionDBModel> objList = <StaticSelectionDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = StaticSelectionDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('StaticSelection.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('StaticSelection.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns StaticSelectionDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? static_selection_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns StaticSelectionDBModel if exist, otherwise returns null
  Future<StaticSelectionDBModel?> getById(int? static_selection_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (static_selection_id == null) {
      return null;
    }
    StaticSelectionDBModel? obj;
    final data = await _mnStaticSelectionDBModel.getById([static_selection_id]);
    if (data.length != 0) {
      obj = StaticSelectionDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('StaticSelection.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('StaticSelection.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (StaticSelectionDBModel) object. If the static_selection_id field is null, saves as a new record and returns new static_selection_id, if static_selection_id is not null then updates record

  /// <returns>Returns static_selection_id
  Future<int?> save() async {
    if (static_selection_id == null || static_selection_id == 0) {
      static_selection_id = await _mnStaticSelectionDBModel.insert(this);
    } else {
      // static_selection_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnStaticSelectionDBModel.update(this);
    }

    return static_selection_id;
  }

  /// saveAs StaticSelectionDBModel. Returns a new Primary Key value of StaticSelectionDBModel

  /// <returns>Returns a new Primary Key value of StaticSelectionDBModel
  Future<int?> saveAs() async {
    static_selection_id = null;

    return save();
  }

  /// saveAll method saves the sent List<StaticSelectionDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<StaticSelectionDBModel> staticselectiondbmodels) async {
    // final results = _mnStaticSelectionDBModel.saveAll('INSERT OR REPLACE INTO StaticSelection (static_selection_id,options, field_type_id)  VALUES (?,?,?)',staticselectiondbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in staticselectiondbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < staticselectiondbmodels.length; i++) {
      if (staticselectiondbmodels[i].static_selection_id == null) {
        staticselectiondbmodels[i].static_selection_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns static_selection_id

  Future<int?> upsert() async {
    try {
      final result = await _mnStaticSelectionDBModel.rawInsert(
          'INSERT OR REPLACE INTO StaticSelection (static_selection_id,options, field_type_id)  VALUES (?,?,?)',
          [static_selection_id, options, field_type_id]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'StaticSelectionDBModel static_selection_id=$static_selection_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'StaticSelectionDBModel static_selection_id=$static_selection_id did not update');
      }
      return static_selection_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'StaticSelectionDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<StaticSelectionDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<StaticSelectionDBModel> staticselectiondbmodels) async {
    final results = await _mnStaticSelectionDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO StaticSelection (static_selection_id,options, field_type_id)  VALUES (?,?,?)',
        staticselectiondbmodels);
    return results;
  }

  /// Deletes StaticSelectionDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete StaticSelectionDBModel invoked (static_selection_id=$static_selection_id)');
    if (await VStaticSelection()
            .select()
            .static_selection_id
            .equals(static_selection_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VStaticSelection.static_selection_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnStaticSelectionDBModel.delete(QueryParams(
          whereString: 'static_selection_id=?',
          whereArguments: [static_selection_id]));
    } else {
      return _mnStaticSelectionDBModel.updateBatch(
          QueryParams(
              whereString: 'static_selection_id=?',
              whereArguments: [static_selection_id]),
          {'isDeleted': 1});
    }
  }

  StaticSelectionDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return StaticSelectionDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  StaticSelectionDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return StaticSelectionDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion staticselectiondbmodel

// region StaticSelectionDBModelField
class StaticSelectionDBModelField extends SearchCriteria {
  StaticSelectionDBModelField(this.staticselectiondbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  StaticSelectionDBModelFilterBuilder staticselectiondbmodelFB;

  StaticSelectionDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  StaticSelectionDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.EQuals, staticselectiondbmodelFB._addedBlocks)
        : setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, staticselectiondbmodelFB._addedBlocks)
        : setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder isNull() {
    staticselectiondbmodelFB._addedBlocks = setCriteria(
        0,
        staticselectiondbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      staticselectiondbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          staticselectiondbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          staticselectiondbmodelFB._addedBlocks);
      _waitingNot = '';
      staticselectiondbmodelFB._addedBlocks
              .needEndBlock![staticselectiondbmodelFB._blockIndex] =
          staticselectiondbmodelFB._addedBlocks.retVal;
    }
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      staticselectiondbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          staticselectiondbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          staticselectiondbmodelFB._addedBlocks);
      _waitingNot = '';
      staticselectiondbmodelFB._addedBlocks
              .needEndBlock![staticselectiondbmodelFB._blockIndex] =
          staticselectiondbmodelFB._addedBlocks.retVal;
      staticselectiondbmodelFB._addedBlocks
              .needEndBlock![staticselectiondbmodelFB._blockIndex] =
          staticselectiondbmodelFB._addedBlocks.retVal;
    }
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      staticselectiondbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          staticselectiondbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          staticselectiondbmodelFB._addedBlocks);
      _waitingNot = '';
      staticselectiondbmodelFB._addedBlocks
              .needEndBlock![staticselectiondbmodelFB._blockIndex] =
          staticselectiondbmodelFB._addedBlocks.retVal;
    }
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      staticselectiondbmodelFB._addedBlocks = setCriteria(
          pFirst,
          staticselectiondbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          staticselectiondbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        staticselectiondbmodelFB._addedBlocks = setCriteria(
            pFirst,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            staticselectiondbmodelFB._addedBlocks);
      } else {
        staticselectiondbmodelFB._addedBlocks = setCriteria(
            pFirst,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            staticselectiondbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        staticselectiondbmodelFB._addedBlocks = setCriteria(
            pLast,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            staticselectiondbmodelFB._addedBlocks);
      } else {
        staticselectiondbmodelFB._addedBlocks = setCriteria(
            pLast,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            staticselectiondbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, staticselectiondbmodelFB._addedBlocks)
        : setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.LessThan, staticselectiondbmodelFB._addedBlocks)
        : setCriteria(
            pValue,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(
            pValue,
            staticselectiondbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            staticselectiondbmodelFB._addedBlocks)
        : setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.LessThan, staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    staticselectiondbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, staticselectiondbmodelFB._addedBlocks)
        : setCriteria(pValue, staticselectiondbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }

  StaticSelectionDBModelFilterBuilder inValues(dynamic pValue) {
    staticselectiondbmodelFB._addedBlocks = setCriteria(
        pValue,
        staticselectiondbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        staticselectiondbmodelFB._addedBlocks);
    _waitingNot = '';
    staticselectiondbmodelFB
            ._addedBlocks.needEndBlock![staticselectiondbmodelFB._blockIndex] =
        staticselectiondbmodelFB._addedBlocks.retVal;
    return staticselectiondbmodelFB;
  }
}
// endregion StaticSelectionDBModelField

// region StaticSelectionDBModelFilterBuilder
class StaticSelectionDBModelFilterBuilder extends SearchCriteria {
  StaticSelectionDBModelFilterBuilder(StaticSelectionDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  StaticSelectionDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  StaticSelectionDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  StaticSelectionDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  StaticSelectionDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  StaticSelectionDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  StaticSelectionDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  StaticSelectionDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  StaticSelectionDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  StaticSelectionDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  StaticSelectionDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  StaticSelectionDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  StaticSelectionDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  StaticSelectionDBModelField setField(
      StaticSelectionDBModelField? field, String colName, DbType dbtype) {
    return StaticSelectionDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  StaticSelectionDBModelField? _static_selection_id;
  StaticSelectionDBModelField get static_selection_id {
    return _static_selection_id =
        setField(_static_selection_id, 'static_selection_id', DbType.integer);
  }

  StaticSelectionDBModelField? _options;
  StaticSelectionDBModelField get options {
    return _options = setField(_options, 'options', DbType.text);
  }

  StaticSelectionDBModelField? _field_type_id;
  StaticSelectionDBModelField get field_type_id {
    return _field_type_id =
        setField(_field_type_id, 'field_type_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (StaticSelectionDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<StaticSelectionDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (VStaticSelection) according to DeleteRule.NO_ACTION

    final idListVStaticSelectionBYstatic_selection_id =
        toListPrimaryKeySQL(false);
    final resVStaticSelectionBYstatic_selection_id = await VStaticSelection()
        .select()
        .where(
            'static_selection_id IN (${idListVStaticSelectionBYstatic_selection_id['sql']})',
            parameterValue: idListVStaticSelectionBYstatic_selection_id['args'])
        .toCount();
    if (resVStaticSelectionBYstatic_selection_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VStaticSelection.static_selection_id)');
    }

    if (StaticSelectionDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnStaticSelectionDBModel
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnStaticSelectionDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'static_selection_id IN (SELECT static_selection_id from StaticSelection ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnStaticSelectionDBModel.updateBatch(qparams, values);
  }

  /// This method always returns StaticSelectionDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<StaticSelectionDBModel>
  Future<StaticSelectionDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnStaticSelectionDBModel.toList(qparams);
    final data = await objFuture;
    StaticSelectionDBModel? obj;
    if (data.isNotEmpty) {
      obj = StaticSelectionDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('StaticSelection.plVStaticSelections') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVStaticSelections'))) {
          /*_loadedfields!.add('StaticSelection.plVStaticSelections'); */ obj
                  .plVStaticSelections =
              obj.plVStaticSelections ??
                  await obj.getVStaticSelections()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [StaticSelectionDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? staticselectiondbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final staticselectiondbmodelsFuture =
        await _obj!._mnStaticSelectionDBModel.toList(qparams);
    final int count = staticselectiondbmodelsFuture[0]['CNT'] as int;
    if (staticselectiondbmodelCount != null) {
      staticselectiondbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<StaticSelectionDBModel> [StaticSelectionDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<StaticSelectionDBModel>
  Future<List<StaticSelectionDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<StaticSelectionDBModel> staticselectiondbmodelsData =
        await StaticSelectionDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return staticselectiondbmodelsData;
  }

  /// This method returns Json String [StaticSelectionDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [StaticSelectionDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [StaticSelectionDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnStaticSelectionDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [StaticSelectionDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `static_selection_id` FROM StaticSelection WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> static_selection_idData = <int>[];
    qparams.selectColumns = ['static_selection_id'];
    final static_selection_idFuture =
        await _obj!._mnStaticSelectionDBModel.toList(qparams);

    final int count = static_selection_idFuture.length;
    for (int i = 0; i < count; i++) {
      static_selection_idData
          .add(static_selection_idFuture[i]['static_selection_id'] as int);
    }
    return static_selection_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [StaticSelectionDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnStaticSelectionDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await StaticSelectionDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnStaticSelectionDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion StaticSelectionDBModelFilterBuilder

// region StaticSelectionDBModelFields
class StaticSelectionDBModelFields {
  static TableField? _fStatic_selection_id;
  static TableField get static_selection_id {
    return _fStatic_selection_id = _fStatic_selection_id ??
        SqlSyntax.setField(
            _fStatic_selection_id, 'static_selection_id', DbType.integer);
  }

  static TableField? _fOptions;
  static TableField get options {
    return _fOptions =
        _fOptions ?? SqlSyntax.setField(_fOptions, 'options', DbType.text);
  }

  static TableField? _fField_type_id;
  static TableField get field_type_id {
    return _fField_type_id = _fField_type_id ??
        SqlSyntax.setField(_fField_type_id, 'field_type_id', DbType.integer);
  }
}
// endregion StaticSelectionDBModelFields

//region StaticSelectionDBModelManager
class StaticSelectionDBModelManager extends SqfEntityProvider {
  StaticSelectionDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'StaticSelection';
  static final List<String> _primaryKeyList = ['static_selection_id'];
  static final String _whereStr = 'static_selection_id=?';
}

//endregion StaticSelectionDBModelManager
// region FieldValueDBModel
class FieldValueDBModel {
  FieldValueDBModel(
      {this.field_value_id, this.value, this.geodata_id, this.column_id}) {
    _setDefaultValues();
  }
  FieldValueDBModel.withFields(this.value, this.geodata_id, this.column_id) {
    _setDefaultValues();
  }
  FieldValueDBModel.withId(
      this.field_value_id, this.value, this.geodata_id, this.column_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FieldValueDBModel.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    field_value_id = int.tryParse(o['field_value_id'].toString());
    if (o['value'] != null) {
      value = o['value'].toString();
    }
    geodata_id = int.tryParse(o['geodata_id'].toString());

    column_id = int.tryParse(o['column_id'].toString());

    // RELATIONSHIPS FromMAP
    plGeodataDBModel = o['geodataDBModel'] != null
        ? GeodataDBModel.fromMap(o['geodataDBModel'] as Map<String, dynamic>)
        : null;
    plFieldTypeDBModel = o['fieldTypeDBModel'] != null
        ? FieldTypeDBModel.fromMap(
            o['fieldTypeDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (FieldValueDBModel)
  int? field_value_id;
  String? value;
  int? geodata_id;
  int? column_id;

  BoolResult? saveResult;
  // end FIELDS (FieldValueDBModel)

// RELATIONSHIPS (FieldValueDBModel)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plGeodataDBModel', 'plField2'..]) or so on..
  GeodataDBModel? plGeodataDBModel;

  /// get GeodataDBModel By Geodata_id
  Future<GeodataDBModel?> getGeodataDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await GeodataDBModel().getById(geodata_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldTypeDBModel', 'plField2'..]) or so on..
  FieldTypeDBModel? plFieldTypeDBModel;

  /// get FieldTypeDBModel By Column_id
  Future<FieldTypeDBModel?> getFieldTypeDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await FieldTypeDBModel().getById(column_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (FieldValueDBModel)

  static const bool _softDeleteActivated = false;
  FieldValueDBModelManager? __mnFieldValueDBModel;

  FieldValueDBModelManager get _mnFieldValueDBModel {
    return __mnFieldValueDBModel =
        __mnFieldValueDBModel ?? FieldValueDBModelManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (field_value_id != null) {
      map['field_value_id'] = field_value_id;
    }
    if (value != null) {
      map['value'] = value;
    }

    if (geodata_id != null) {
      map['geodata_id'] = forView
          ? plGeodataDBModel == null
              ? geodata_id
              : plGeodataDBModel!.geodata_id
          : geodata_id;
    }

    if (column_id != null) {
      map['column_id'] = forView
          ? plFieldTypeDBModel == null
              ? column_id
              : plFieldTypeDBModel!.name
          : column_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (field_value_id != null) {
      map['field_value_id'] = field_value_id;
    }
    if (value != null) {
      map['value'] = value;
    }

    if (geodata_id != null) {
      map['geodata_id'] = forView
          ? plGeodataDBModel == null
              ? geodata_id
              : plGeodataDBModel!.geodata_id
          : geodata_id;
    }

    if (column_id != null) {
      map['column_id'] = forView
          ? plFieldTypeDBModel == null
              ? column_id
              : plFieldTypeDBModel!.name
          : column_id;
    }

    return map;
  }

  /// This method returns Json String [FieldValueDBModel]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FieldValueDBModel]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [value, geodata_id, column_id];
  }

  List<dynamic> toArgsWithIds() {
    return [field_value_id, value, geodata_id, column_id];
  }

  static Future<List<FieldValueDBModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR FieldValueDBModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FieldValueDBModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FieldValueDBModel>[];
    try {
      objList = list
          .map((fieldvaluedbmodel) => FieldValueDBModel.fromMap(
              fieldvaluedbmodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR FieldValueDBModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FieldValueDBModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FieldValueDBModel> objList = <FieldValueDBModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FieldValueDBModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plGeodataDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGeodataDBModel'))) {
          /*_loadedfields!.add('Geodata.plGeodataDBModel');*/ obj
              .plGeodataDBModel = obj
                  .plGeodataDBModel ??
              await obj.getGeodataDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FieldValueDBModel by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? field_value_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns FieldValueDBModel if exist, otherwise returns null
  Future<FieldValueDBModel?> getById(int? field_value_id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (field_value_id == null) {
      return null;
    }
    FieldValueDBModel? obj;
    final data = await _mnFieldValueDBModel.getById([field_value_id]);
    if (data.length != 0) {
      obj = FieldValueDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plGeodataDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGeodataDBModel'))) {
          /*_loadedfields!.add('Geodata.plGeodataDBModel');*/ obj
              .plGeodataDBModel = obj
                  .plGeodataDBModel ??
              await obj.getGeodataDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FieldValueDBModel) object. If the field_value_id field is null, saves as a new record and returns new field_value_id, if field_value_id is not null then updates record

  /// <returns>Returns field_value_id
  Future<int?> save() async {
    if (field_value_id == null || field_value_id == 0) {
      field_value_id = await _mnFieldValueDBModel.insert(this);
    } else {
      // field_value_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFieldValueDBModel.update(this);
    }

    return field_value_id;
  }

  /// saveAs FieldValueDBModel. Returns a new Primary Key value of FieldValueDBModel

  /// <returns>Returns a new Primary Key value of FieldValueDBModel
  Future<int?> saveAs() async {
    field_value_id = null;

    return save();
  }

  /// saveAll method saves the sent List<FieldValueDBModel> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<FieldValueDBModel> fieldvaluedbmodels) async {
    // final results = _mnFieldValueDBModel.saveAll('INSERT OR REPLACE INTO FieldValue (field_value_id,value, geodata_id, column_id)  VALUES (?,?,?,?)',fieldvaluedbmodels);
    // return results; removed in sqfentity_gen 1.3.0+6
    await GeobaseModel().batchStart();
    for (final obj in fieldvaluedbmodels) {
      await obj.save();
    }
    //    return GeobaseModel().batchCommit();
    final result = await GeobaseModel().batchCommit();
    for (int i = 0; i < fieldvaluedbmodels.length; i++) {
      if (fieldvaluedbmodels[i].field_value_id == null) {
        fieldvaluedbmodels[i].field_value_id = result![i] as int;
      }
    }

    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns field_value_id

  Future<int?> upsert() async {
    try {
      final result = await _mnFieldValueDBModel.rawInsert(
          'INSERT OR REPLACE INTO FieldValue (field_value_id,value, geodata_id, column_id)  VALUES (?,?,?,?)',
          [field_value_id, value, geodata_id, column_id]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FieldValueDBModel field_value_id=$field_value_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FieldValueDBModel field_value_id=$field_value_id did not update');
      }
      return field_value_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'FieldValueDBModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FieldValueDBModel>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<FieldValueDBModel> fieldvaluedbmodels) async {
    final results = await _mnFieldValueDBModel.rawInsertAll(
        'INSERT OR REPLACE INTO FieldValue (field_value_id,value, geodata_id, column_id)  VALUES (?,?,?,?)',
        fieldvaluedbmodels);
    return results;
  }

  /// Deletes FieldValueDBModel

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete FieldValueDBModel invoked (field_value_id=$field_value_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnFieldValueDBModel.delete(QueryParams(
          whereString: 'field_value_id=?', whereArguments: [field_value_id]));
    } else {
      return _mnFieldValueDBModel.updateBatch(
          QueryParams(
              whereString: 'field_value_id=?',
              whereArguments: [field_value_id]),
          {'isDeleted': 1});
    }
  }

  FieldValueDBModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FieldValueDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FieldValueDBModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FieldValueDBModelFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion fieldvaluedbmodel

// region FieldValueDBModelField
class FieldValueDBModelField extends SearchCriteria {
  FieldValueDBModelField(this.fieldvaluedbmodelFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  FieldValueDBModelFilterBuilder fieldvaluedbmodelFB;

  FieldValueDBModelField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FieldValueDBModelFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.EQuals, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.NotEQuals, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.EQualsOrNull, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder isNull() {
    fieldvaluedbmodelFB._addedBlocks = setCriteria(
        0,
        fieldvaluedbmodelFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fieldvaluedbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fieldvaluedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldvaluedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldvaluedbmodelFB
              ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
          fieldvaluedbmodelFB._addedBlocks.retVal;
    }
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fieldvaluedbmodelFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fieldvaluedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldvaluedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldvaluedbmodelFB
              ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
          fieldvaluedbmodelFB._addedBlocks.retVal;
      fieldvaluedbmodelFB
              ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
          fieldvaluedbmodelFB._addedBlocks.retVal;
    }
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fieldvaluedbmodelFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fieldvaluedbmodelFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldvaluedbmodelFB._addedBlocks);
      _waitingNot = '';
      fieldvaluedbmodelFB
              ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
          fieldvaluedbmodelFB._addedBlocks.retVal;
    }
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fieldvaluedbmodelFB._addedBlocks = setCriteria(
          pFirst,
          fieldvaluedbmodelFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fieldvaluedbmodelFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fieldvaluedbmodelFB._addedBlocks = setCriteria(
            pFirst,
            fieldvaluedbmodelFB.parameters,
            param,
            SqlSyntax.LessThan,
            fieldvaluedbmodelFB._addedBlocks);
      } else {
        fieldvaluedbmodelFB._addedBlocks = setCriteria(
            pFirst,
            fieldvaluedbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            fieldvaluedbmodelFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fieldvaluedbmodelFB._addedBlocks = setCriteria(
            pLast,
            fieldvaluedbmodelFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            fieldvaluedbmodelFB._addedBlocks);
      } else {
        fieldvaluedbmodelFB._addedBlocks = setCriteria(
            pLast,
            fieldvaluedbmodelFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            fieldvaluedbmodelFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.LessThan, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.LessThan, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fieldvaluedbmodelFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fieldvaluedbmodelFB._addedBlocks)
        : setCriteria(pValue, fieldvaluedbmodelFB.parameters, param,
            SqlSyntax.GreaterThan, fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }

  FieldValueDBModelFilterBuilder inValues(dynamic pValue) {
    fieldvaluedbmodelFB._addedBlocks = setCriteria(
        pValue,
        fieldvaluedbmodelFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fieldvaluedbmodelFB._addedBlocks);
    _waitingNot = '';
    fieldvaluedbmodelFB
            ._addedBlocks.needEndBlock![fieldvaluedbmodelFB._blockIndex] =
        fieldvaluedbmodelFB._addedBlocks.retVal;
    return fieldvaluedbmodelFB;
  }
}
// endregion FieldValueDBModelField

// region FieldValueDBModelFilterBuilder
class FieldValueDBModelFilterBuilder extends SearchCriteria {
  FieldValueDBModelFilterBuilder(FieldValueDBModel obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  FieldValueDBModel? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  FieldValueDBModelFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FieldValueDBModelFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FieldValueDBModelFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FieldValueDBModelFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FieldValueDBModelFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FieldValueDBModelFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FieldValueDBModelFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FieldValueDBModelFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FieldValueDBModelFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FieldValueDBModelFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FieldValueDBModelFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FieldValueDBModelField setField(
      FieldValueDBModelField? field, String colName, DbType dbtype) {
    return FieldValueDBModelField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  FieldValueDBModelField? _field_value_id;
  FieldValueDBModelField get field_value_id {
    return _field_value_id =
        setField(_field_value_id, 'field_value_id', DbType.integer);
  }

  FieldValueDBModelField? _value;
  FieldValueDBModelField get value {
    return _value = setField(_value, 'value', DbType.text);
  }

  FieldValueDBModelField? _geodata_id;
  FieldValueDBModelField get geodata_id {
    return _geodata_id = setField(_geodata_id, 'geodata_id', DbType.integer);
  }

  FieldValueDBModelField? _column_id;
  FieldValueDBModelField get column_id {
    return _column_id = setField(_column_id, 'column_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (FieldValueDBModel._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<FieldValueDBModel> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (FieldValueDBModel._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnFieldValueDBModel
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnFieldValueDBModel.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'field_value_id IN (SELECT field_value_id from FieldValue ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnFieldValueDBModel.updateBatch(qparams, values);
  }

  /// This method always returns FieldValueDBModel Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FieldValueDBModel>
  Future<FieldValueDBModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnFieldValueDBModel.toList(qparams);
    final data = await objFuture;
    FieldValueDBModel? obj;
    if (data.isNotEmpty) {
      obj = FieldValueDBModel.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plGeodataDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGeodataDBModel'))) {
          /*_loadedfields!.add('Geodata.plGeodataDBModel');*/ obj
              .plGeodataDBModel = obj
                  .plGeodataDBModel ??
              await obj.getGeodataDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [FieldValueDBModel]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? fieldvaluedbmodelCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fieldvaluedbmodelsFuture =
        await _obj!._mnFieldValueDBModel.toList(qparams);
    final int count = fieldvaluedbmodelsFuture[0]['CNT'] as int;
    if (fieldvaluedbmodelCount != null) {
      fieldvaluedbmodelCount(count);
    }
    return count;
  }

  /// This method returns List<FieldValueDBModel> [FieldValueDBModel]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FieldValueDBModel>
  Future<List<FieldValueDBModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FieldValueDBModel> fieldvaluedbmodelsData =
        await FieldValueDBModel.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return fieldvaluedbmodelsData;
  }

  /// This method returns Json String [FieldValueDBModel]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FieldValueDBModel]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FieldValueDBModel]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnFieldValueDBModel.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FieldValueDBModel]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `field_value_id` FROM FieldValue WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> field_value_idData = <int>[];
    qparams.selectColumns = ['field_value_id'];
    final field_value_idFuture =
        await _obj!._mnFieldValueDBModel.toList(qparams);

    final int count = field_value_idFuture.length;
    for (int i = 0; i < count; i++) {
      field_value_idData.add(field_value_idFuture[i]['field_value_id'] as int);
    }
    return field_value_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FieldValueDBModel]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnFieldValueDBModel.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await FieldValueDBModel.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnFieldValueDBModel.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FieldValueDBModelFilterBuilder

// region FieldValueDBModelFields
class FieldValueDBModelFields {
  static TableField? _fField_value_id;
  static TableField get field_value_id {
    return _fField_value_id = _fField_value_id ??
        SqlSyntax.setField(_fField_value_id, 'field_value_id', DbType.integer);
  }

  static TableField? _fValue;
  static TableField get value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'value', DbType.text);
  }

  static TableField? _fGeodata_id;
  static TableField get geodata_id {
    return _fGeodata_id = _fGeodata_id ??
        SqlSyntax.setField(_fGeodata_id, 'geodata_id', DbType.integer);
  }

  static TableField? _fColumn_id;
  static TableField get column_id {
    return _fColumn_id = _fColumn_id ??
        SqlSyntax.setField(_fColumn_id, 'column_id', DbType.integer);
  }
}
// endregion FieldValueDBModelFields

//region FieldValueDBModelManager
class FieldValueDBModelManager extends SqfEntityProvider {
  FieldValueDBModelManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'FieldValue';
  static final List<String> _primaryKeyList = ['field_value_id'];
  static final String _whereStr = 'field_value_id=?';
}

//endregion FieldValueDBModelManager
// region VMarker
class VMarker {
  VMarker({this.kind, this.icon, this.color, this.geodata_id}) {
    _setDefaultValues();
  }
  VMarker.withFields(this.kind, this.icon, this.color, this.geodata_id) {
    _setDefaultValues();
  }
  VMarker.withId(this.kind, this.icon, this.color, this.geodata_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  VMarker.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['kind'] != null) {
      kind = o['kind'].toString();
    }
    if (o['icon'] != null) {
      icon = int.tryParse(o['icon'].toString());
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    geodata_id = int.tryParse(o['geodata_id'].toString());

    // RELATIONSHIPS FromMAP
    plGeodataDBModel = o['geodataDBModel'] != null
        ? GeodataDBModel.fromMap(o['geodataDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (VMarker)
  String? kind;
  int? icon;
  int? color;
  int? geodata_id;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (VMarker)

// RELATIONSHIPS (VMarker)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plGeodataDBModel', 'plField2'..]) or so on..
  GeodataDBModel? plGeodataDBModel;

  /// get GeodataDBModel By Geodata_id
  Future<GeodataDBModel?> getGeodataDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await GeodataDBModel().getById(geodata_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (VMarker)

  static const bool _softDeleteActivated = false;
  VMarkerManager? __mnVMarker;

  VMarkerManager get _mnVMarker {
    return __mnVMarker = __mnVMarker ?? VMarkerManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (kind != null) {
      map['kind'] = kind;
    }

    if (icon != null) {
      map['icon'] = icon;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (geodata_id != null) {
      map['geodata_id'] = forView
          ? plGeodataDBModel == null
              ? geodata_id
              : plGeodataDBModel!.geodata_id
          : geodata_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (kind != null) {
      map['kind'] = kind;
    }

    if (icon != null) {
      map['icon'] = icon;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (geodata_id != null) {
      map['geodata_id'] = forView
          ? plGeodataDBModel == null
              ? geodata_id
              : plGeodataDBModel!.geodata_id
          : geodata_id;
    }

    return map;
  }

  /// This method returns Json String [VMarker]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VMarker]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [kind, icon, color, geodata_id];
  }

  List<dynamic> toArgsWithIds() {
    return [kind, icon, color, geodata_id];
  }

  static Future<List<VMarker>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR VMarker.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<VMarker>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VMarker>[];
    try {
      objList = list
          .map((vmarker) => VMarker.fromMap(vmarker as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR VMarker.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VMarker>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<VMarker> objList = <VMarker>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VMarker.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plGeodataDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGeodataDBModel'))) {
          /*_loadedfields!.add('Geodata.plGeodataDBModel');*/ obj
              .plGeodataDBModel = obj
                  .plGeodataDBModel ??
              await obj.getGeodataDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  VMarkerFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VMarkerFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  VMarkerFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VMarkerFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vmarker

// region VMarkerField
class VMarkerField extends SearchCriteria {
  VMarkerField(this.vmarkerFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  VMarkerFilterBuilder vmarkerFB;

  VMarkerField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  VMarkerFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param, SqlSyntax.EQuals,
            vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param, SqlSyntax.NotEQuals,
            vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.EQualsOrNull, vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder isNull() {
    vmarkerFB._addedBlocks = setCriteria(
        0,
        vmarkerFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      vmarkerFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          vmarkerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vmarkerFB._addedBlocks);
      _waitingNot = '';
      vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
          vmarkerFB._addedBlocks.retVal;
    }
    return vmarkerFB;
  }

  VMarkerFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      vmarkerFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          vmarkerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vmarkerFB._addedBlocks);
      _waitingNot = '';
      vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
          vmarkerFB._addedBlocks.retVal;
      vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
          vmarkerFB._addedBlocks.retVal;
    }
    return vmarkerFB;
  }

  VMarkerFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      vmarkerFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          vmarkerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vmarkerFB._addedBlocks);
      _waitingNot = '';
      vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
          vmarkerFB._addedBlocks.retVal;
    }
    return vmarkerFB;
  }

  VMarkerFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      vmarkerFB._addedBlocks = setCriteria(
          pFirst,
          vmarkerFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vmarkerFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        vmarkerFB._addedBlocks = setCriteria(pFirst, vmarkerFB.parameters,
            param, SqlSyntax.LessThan, vmarkerFB._addedBlocks);
      } else {
        vmarkerFB._addedBlocks = setCriteria(pFirst, vmarkerFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, vmarkerFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        vmarkerFB._addedBlocks = setCriteria(pLast, vmarkerFB.parameters, param,
            SqlSyntax.GreaterThan, vmarkerFB._addedBlocks);
      } else {
        vmarkerFB._addedBlocks = setCriteria(pLast, vmarkerFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vmarkerFB._addedBlocks);
      }
    }
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.GreaterThan, vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param, SqlSyntax.LessThan,
            vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param, SqlSyntax.LessThan,
            vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    vmarkerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vmarkerFB._addedBlocks)
        : setCriteria(pValue, vmarkerFB.parameters, param,
            SqlSyntax.GreaterThan, vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }

  VMarkerFilterBuilder inValues(dynamic pValue) {
    vmarkerFB._addedBlocks = setCriteria(
        pValue,
        vmarkerFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vmarkerFB._addedBlocks);
    _waitingNot = '';
    vmarkerFB._addedBlocks.needEndBlock![vmarkerFB._blockIndex] =
        vmarkerFB._addedBlocks.retVal;
    return vmarkerFB;
  }
}
// endregion VMarkerField

// region VMarkerFilterBuilder
class VMarkerFilterBuilder extends SearchCriteria {
  VMarkerFilterBuilder(VMarker obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  VMarker? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  VMarkerFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  VMarkerFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  VMarkerFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  VMarkerFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  VMarkerFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  VMarkerFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  VMarkerFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VMarkerFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VMarkerFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VMarkerFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VMarkerFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  VMarkerField setField(VMarkerField? field, String colName, DbType dbtype) {
    return VMarkerField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  VMarkerField? _kind;
  VMarkerField get kind {
    return _kind = setField(_kind, 'kind', DbType.text);
  }

  VMarkerField? _icon;
  VMarkerField get icon {
    return _icon = setField(_icon, 'icon', DbType.integer);
  }

  VMarkerField? _color;
  VMarkerField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  VMarkerField? _geodata_id;
  VMarkerField get geodata_id {
    return _geodata_id = setField(_geodata_id, 'geodata_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (VMarker._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// This method always returns VMarker Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VMarker>
  Future<VMarker?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnVMarker.toList(qparams);
    final data = await objFuture;
    VMarker? obj;
    if (data.isNotEmpty) {
      obj = VMarker.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Geodata.plGeodataDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGeodataDBModel'))) {
          /*_loadedfields!.add('Geodata.plGeodataDBModel');*/ obj
              .plGeodataDBModel = obj
                  .plGeodataDBModel ??
              await obj.getGeodataDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [VMarker]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? vmarkerCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vmarkersFuture = await _obj!._mnVMarker.toList(qparams);
    final int count = vmarkersFuture[0]['CNT'] as int;
    if (vmarkerCount != null) {
      vmarkerCount(count);
    }
    return count;
  }

  /// This method returns List<VMarker> [VMarker]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VMarker>
  Future<List<VMarker>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<VMarker> vmarkersData = await VMarker.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vmarkersData;
  }

  /// This method returns Json String [VMarker]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VMarker]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VMarker]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnVMarker.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VMarker]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `` FROM VMarkers WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VMarker]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnVMarker.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await VMarker.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnVMarker.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VMarkerFilterBuilder

// region VMarkerFields
class VMarkerFields {
  static TableField? _fKind;
  static TableField get kind {
    return _fKind = _fKind ?? SqlSyntax.setField(_fKind, 'kind', DbType.text);
  }

  static TableField? _fIcon;
  static TableField get icon {
    return _fIcon =
        _fIcon ?? SqlSyntax.setField(_fIcon, 'icon', DbType.integer);
  }

  static TableField? _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField? _fGeodata_id;
  static TableField get geodata_id {
    return _fGeodata_id = _fGeodata_id ??
        SqlSyntax.setField(_fGeodata_id, 'geodata_id', DbType.integer);
  }
}
// endregion VMarkerFields

//region VMarkerManager
class VMarkerManager extends SqfEntityProvider {
  VMarkerManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'VMarkers';
  static final List<String> _primaryKeyList = [''];
  static final String _whereStr = '';
}

//endregion VMarkerManager
// region VStaticSelection
class VStaticSelection {
  VStaticSelection(
      {this.name,
      this.meta_type,
      this.options,
      this.field_type_id,
      this.static_selection_id}) {
    _setDefaultValues();
  }
  VStaticSelection.withFields(this.name, this.meta_type, this.options,
      this.field_type_id, this.static_selection_id) {
    _setDefaultValues();
  }
  VStaticSelection.withId(this.name, this.meta_type, this.options,
      this.field_type_id, this.static_selection_id) {
    _setDefaultValues();
  }
  // fromMap v2.0
  VStaticSelection.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['meta_type'] != null) {
      meta_type = o['meta_type'].toString();
    }
    if (o['options'] != null) {
      options = o['options'].toString();
    }
    field_type_id = int.tryParse(o['field_type_id'].toString());

    static_selection_id = int.tryParse(o['static_selection_id'].toString());

    // RELATIONSHIPS FromMAP
    plFieldTypeDBModel = o['fieldTypeDBModel'] != null
        ? FieldTypeDBModel.fromMap(
            o['fieldTypeDBModel'] as Map<String, dynamic>)
        : null;
    plStaticSelectionDBModel = o['staticSelectionDBModel'] != null
        ? StaticSelectionDBModel.fromMap(
            o['staticSelectionDBModel'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (VStaticSelection)
  String? name;
  String? meta_type;
  String? options;
  int? field_type_id;
  int? static_selection_id;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (VStaticSelection)

// RELATIONSHIPS (VStaticSelection)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFieldTypeDBModel', 'plField2'..]) or so on..
  FieldTypeDBModel? plFieldTypeDBModel;

  /// get FieldTypeDBModel By Field_type_id
  Future<FieldTypeDBModel?> getFieldTypeDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await FieldTypeDBModel().getById(field_type_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plStaticSelectionDBModel', 'plField2'..]) or so on..
  StaticSelectionDBModel? plStaticSelectionDBModel;

  /// get StaticSelectionDBModel By Static_selection_id
  Future<StaticSelectionDBModel?> getStaticSelectionDBModel(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await StaticSelectionDBModel().getById(static_selection_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (VStaticSelection)

  static const bool _softDeleteActivated = false;
  VStaticSelectionManager? __mnVStaticSelection;

  VStaticSelectionManager get _mnVStaticSelection {
    return __mnVStaticSelection =
        __mnVStaticSelection ?? VStaticSelectionManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (name != null) {
      map['name'] = name;
    }

    if (meta_type != null) {
      map['meta_type'] = meta_type;
    }

    if (options != null) {
      map['options'] = options;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

    if (static_selection_id != null) {
      map['static_selection_id'] = forView
          ? plStaticSelectionDBModel == null
              ? static_selection_id
              : plStaticSelectionDBModel!.options
          : static_selection_id;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (name != null) {
      map['name'] = name;
    }

    if (meta_type != null) {
      map['meta_type'] = meta_type;
    }

    if (options != null) {
      map['options'] = options;
    }

    if (field_type_id != null) {
      map['field_type_id'] = forView
          ? plFieldTypeDBModel == null
              ? field_type_id
              : plFieldTypeDBModel!.name
          : field_type_id;
    }

    if (static_selection_id != null) {
      map['static_selection_id'] = forView
          ? plStaticSelectionDBModel == null
              ? static_selection_id
              : plStaticSelectionDBModel!.options
          : static_selection_id;
    }

    return map;
  }

  /// This method returns Json String [VStaticSelection]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VStaticSelection]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, meta_type, options, field_type_id, static_selection_id];
  }

  List<dynamic> toArgsWithIds() {
    return [name, meta_type, options, field_type_id, static_selection_id];
  }

  static Future<List<VStaticSelection>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR VStaticSelection.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<VStaticSelection>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VStaticSelection>[];
    try {
      objList = list
          .map((vstaticselection) => VStaticSelection.fromMap(
              vstaticselection as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR VStaticSelection.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VStaticSelection>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<VStaticSelection> objList = <VStaticSelection>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VStaticSelection.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('StaticSelection.plStaticSelectionDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plStaticSelectionDBModel'))) {
          /*_loadedfields!.add('StaticSelection.plStaticSelectionDBModel');*/ obj
              .plStaticSelectionDBModel = obj
                  .plStaticSelectionDBModel ??
              await obj.getStaticSelectionDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  VStaticSelectionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VStaticSelectionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  VStaticSelectionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VStaticSelectionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vstaticselection

// region VStaticSelectionField
class VStaticSelectionField extends SearchCriteria {
  VStaticSelectionField(this.vstaticselectionFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  VStaticSelectionFilterBuilder vstaticselectionFB;

  VStaticSelectionField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  VStaticSelectionFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.EQuals, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.NotEQuals, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.EQualsOrNull, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder isNull() {
    vstaticselectionFB._addedBlocks = setCriteria(
        0,
        vstaticselectionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      vstaticselectionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          vstaticselectionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vstaticselectionFB._addedBlocks);
      _waitingNot = '';
      vstaticselectionFB
              ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
          vstaticselectionFB._addedBlocks.retVal;
    }
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      vstaticselectionFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          vstaticselectionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vstaticselectionFB._addedBlocks);
      _waitingNot = '';
      vstaticselectionFB
              ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
          vstaticselectionFB._addedBlocks.retVal;
      vstaticselectionFB
              ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
          vstaticselectionFB._addedBlocks.retVal;
    }
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      vstaticselectionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          vstaticselectionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vstaticselectionFB._addedBlocks);
      _waitingNot = '';
      vstaticselectionFB
              ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
          vstaticselectionFB._addedBlocks.retVal;
    }
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      vstaticselectionFB._addedBlocks = setCriteria(
          pFirst,
          vstaticselectionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vstaticselectionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        vstaticselectionFB._addedBlocks = setCriteria(
            pFirst,
            vstaticselectionFB.parameters,
            param,
            SqlSyntax.LessThan,
            vstaticselectionFB._addedBlocks);
      } else {
        vstaticselectionFB._addedBlocks = setCriteria(
            pFirst,
            vstaticselectionFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            vstaticselectionFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        vstaticselectionFB._addedBlocks = setCriteria(
            pLast,
            vstaticselectionFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            vstaticselectionFB._addedBlocks);
      } else {
        vstaticselectionFB._addedBlocks = setCriteria(
            pLast,
            vstaticselectionFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            vstaticselectionFB._addedBlocks);
      }
    }
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.GreaterThan, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.LessThan, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.LessThan, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    vstaticselectionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vstaticselectionFB._addedBlocks)
        : setCriteria(pValue, vstaticselectionFB.parameters, param,
            SqlSyntax.GreaterThan, vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }

  VStaticSelectionFilterBuilder inValues(dynamic pValue) {
    vstaticselectionFB._addedBlocks = setCriteria(
        pValue,
        vstaticselectionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vstaticselectionFB._addedBlocks);
    _waitingNot = '';
    vstaticselectionFB
            ._addedBlocks.needEndBlock![vstaticselectionFB._blockIndex] =
        vstaticselectionFB._addedBlocks.retVal;
    return vstaticselectionFB;
  }
}
// endregion VStaticSelectionField

// region VStaticSelectionFilterBuilder
class VStaticSelectionFilterBuilder extends SearchCriteria {
  VStaticSelectionFilterBuilder(VStaticSelection obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  VStaticSelection? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  VStaticSelectionFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  VStaticSelectionFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  VStaticSelectionFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  VStaticSelectionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  VStaticSelectionFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  VStaticSelectionFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  VStaticSelectionFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VStaticSelectionFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VStaticSelectionFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VStaticSelectionFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VStaticSelectionFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  VStaticSelectionField setField(
      VStaticSelectionField? field, String colName, DbType dbtype) {
    return VStaticSelectionField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  VStaticSelectionField? _name;
  VStaticSelectionField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  VStaticSelectionField? _meta_type;
  VStaticSelectionField get meta_type {
    return _meta_type = setField(_meta_type, 'meta_type', DbType.text);
  }

  VStaticSelectionField? _options;
  VStaticSelectionField get options {
    return _options = setField(_options, 'options', DbType.text);
  }

  VStaticSelectionField? _field_type_id;
  VStaticSelectionField get field_type_id {
    return _field_type_id =
        setField(_field_type_id, 'field_type_id', DbType.integer);
  }

  VStaticSelectionField? _static_selection_id;
  VStaticSelectionField get static_selection_id {
    return _static_selection_id =
        setField(_static_selection_id, 'static_selection_id', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (VStaticSelection._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// This method always returns VStaticSelection Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VStaticSelection>
  Future<VStaticSelection?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnVStaticSelection.toList(qparams);
    final data = await objFuture;
    VStaticSelection? obj;
    if (data.isNotEmpty) {
      obj = VStaticSelection.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FieldType.plFieldTypeDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plFieldTypeDBModel'))) {
          /*_loadedfields!.add('FieldType.plFieldTypeDBModel');*/ obj
              .plFieldTypeDBModel = obj
                  .plFieldTypeDBModel ??
              await obj.getFieldTypeDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('StaticSelection.plStaticSelectionDBModel') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plStaticSelectionDBModel'))) {
          /*_loadedfields!.add('StaticSelection.plStaticSelectionDBModel');*/ obj
              .plStaticSelectionDBModel = obj
                  .plStaticSelectionDBModel ??
              await obj.getStaticSelectionDBModel(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [VStaticSelection]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? vstaticselectionCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vstaticselectionsFuture =
        await _obj!._mnVStaticSelection.toList(qparams);
    final int count = vstaticselectionsFuture[0]['CNT'] as int;
    if (vstaticselectionCount != null) {
      vstaticselectionCount(count);
    }
    return count;
  }

  /// This method returns List<VStaticSelection> [VStaticSelection]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VStaticSelection>
  Future<List<VStaticSelection>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<VStaticSelection> vstaticselectionsData =
        await VStaticSelection.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return vstaticselectionsData;
  }

  /// This method returns Json String [VStaticSelection]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VStaticSelection]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VStaticSelection]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnVStaticSelection.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VStaticSelection]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `` FROM VStaticSelections WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VStaticSelection]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnVStaticSelection.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await VStaticSelection.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnVStaticSelection.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VStaticSelectionFilterBuilder

// region VStaticSelectionFields
class VStaticSelectionFields {
  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fMeta_type;
  static TableField get meta_type {
    return _fMeta_type = _fMeta_type ??
        SqlSyntax.setField(_fMeta_type, 'meta_type', DbType.text);
  }

  static TableField? _fOptions;
  static TableField get options {
    return _fOptions =
        _fOptions ?? SqlSyntax.setField(_fOptions, 'options', DbType.text);
  }

  static TableField? _fField_type_id;
  static TableField get field_type_id {
    return _fField_type_id = _fField_type_id ??
        SqlSyntax.setField(_fField_type_id, 'field_type_id', DbType.integer);
  }

  static TableField? _fStatic_selection_id;
  static TableField get static_selection_id {
    return _fStatic_selection_id = _fStatic_selection_id ??
        SqlSyntax.setField(
            _fStatic_selection_id, 'static_selection_id', DbType.integer);
  }
}
// endregion VStaticSelectionFields

//region VStaticSelectionManager
class VStaticSelectionManager extends SqfEntityProvider {
  VStaticSelectionManager()
      : super(GeobaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'VStaticSelections';
  static final List<String> _primaryKeyList = [''];
  static final String _whereStr = '';
}

//endregion VStaticSelectionManager
class GeobaseModelSequenceManager extends SqfEntityProvider {
  GeobaseModelSequenceManager() : super(GeobaseModel());
}
// END OF ENTITIES
